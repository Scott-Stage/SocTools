/// <summary>
    /// Extracts the literal tokens from a union pattern like:
    /// (?i)(?:ftb\.|ca\.|ftb\.ca|ftbca|ftbgov\.)
    /// Returns: ["ftb.", "ca.", "ftb.ca", "ftbca", "ftbgov."]
    /// Also tolerates tokens written as \Q...\E.
    /// </summary>
    public static IReadOnlyList<string> ExtractTokens(string pattern)
    {
        if (string.IsNullOrWhiteSpace(pattern))
            return Array.Empty<string>();

        pattern = pattern.Trim();

        // Drop leading inline options like (?i) or (?imx-...)
        pattern = Regex.Replace(pattern, @"^\(\?[A-Za-z\-]+\)", "");

        // Remove outer wrappers like (?: ... ) or ( ... ) and ^...$
        pattern = TrimOuterGroup(pattern);

        // Split on '|' that is not escaped (no heavy regex features assumed here)
        var tokens = SplitOnUnion(pattern);

        // Unwrap each token: remove anchors, \Q...\E if present, and unescape backslashes
        var result = new List<string>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var raw in tokens)
        {
            var t = raw.Trim();
            if (t.Length == 0) continue;

            // strip ^ and $ if they are used inside individual tokens
            if (t.StartsWith("^")) t = t[1..];
            if (t.EndsWith("$"))   t = t[..^1];

            // unwrap \Q...\E (rare in .NET, but supported here)
            var m = Regex.Match(t, @"^\\Q(?<q>.*)\\E$", RegexOptions.Singleline);
            if (m.Success) t = m.Groups["q"].Value;

            // turn ftb\.ca into ftb.ca, etc.
            t = Regex.Unescape(t);

            if (t.Length > 0 && seen.Add(t))
                result.Add(t);
        }

        return result;
    }

    private static string TrimOuterGroup(string s)
    {
        s = s.Trim();

        // Remove leading ^ and trailing $ around the whole union
        if (s.StartsWith("^")) s = s[1..];
        if (s.EndsWith("$"))   s = s[..^1];

        // Peel multiple layers of (?: ... ) or ( ... )
        bool changed;
        do
        {
            changed = false;
            if (s.StartsWith("(?:") && s.EndsWith(")") && IsBalancedParens(s))
            {
                s = s.Substring(3, s.Length - 4);
                changed = true;
                continue;
            }
            if (s.StartsWith("(") && s.EndsWith(")") && IsBalancedParens(s))
            {
                s = s.Substring(1, s.Length - 2);
                changed = true;
            }
        } while (changed);

        return s.Trim();
    }

    private static bool IsBalancedParens(string s)
    {
        int depth = 0;
        for (int i = 0; i < s.Length; i++)
        {
            char c = s[i];
            if (c == '\\') { i++; continue; } // skip escaped char
            if (c == '(') depth++;
            else if (c == ')')
            {
                depth--;
                if (depth < 0) return false;
            }
        }
        return depth == 0;
    }

    private static List<string> SplitOnUnion(string s)
    {
        var parts = new List<string>();
        var sb = new StringBuilder();
        bool escaped = false;

        for (int i = 0; i < s.Length; i++)
        {
            char c = s[i];

            if (escaped)
            {
                sb.Append(c);
                escaped = false;
                continue;
            }

            if (c == '\\')
            {
                escaped = true;
                sb.Append(c); // keep the backslash; we'll unescape later
                continue;
            }

            if (c == '|')
            {
                parts.Add(sb.ToString());
                sb.Clear();
                continue;
            }

            sb.Append(c);
        }

        parts.Add(sb.ToString());
        return parts;
    }