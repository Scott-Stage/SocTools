Option A â€” Recommended: explicit typed async lambda
This is the simplest and most robust approach:

razor
Copy
Edit
<MudDropContainer T="DashboardItem"
                  Items="@dashboardItems"
                  ItemDropped="@(async (MudItemDropInfo<DashboardItem> info) => await OnItemDropped(info))"
                  Class="d-flex flex-wrap">
    ...
</MudDropContainer>
And in @code:

csharp
Copy
Edit
private async Task OnItemDropped(MudItemDropInfo<DashboardItem> info)
{
    if (info == null) return;
    var item = info.Item;
    var oldIndex = dashboardItems.IndexOf(item);
    if (oldIndex >= 0) dashboardItems.RemoveAt(oldIndex);
    var insertIndex = Math.Max(0, Math.Min(info.Index, dashboardItems.Count));
    dashboardItems.Insert(insertIndex, item);
    await InvokeAsync(StateHasChanged);
}
Why this fixes things:

The lambda explicitly types info as MudItemDropInfo<DashboardItem>, so Razor/compiler knows the delegate type.

ItemDropped receives an EventCallback<MudItemDropInfo<DashboardItem>> created from the lambda.