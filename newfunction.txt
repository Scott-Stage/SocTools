// Services/ComponentTaskRunner.cs
// No change to registration in Program.cs
public class ComponentTaskRunner : IDisposable
{
    private CancellationTokenSource? _cts;

    // The Start method now takes an Action to be called after the work is done.
    public void Start(Func<Task> work, Action onStateHasChanged, TimeSpan interval)
    {
        _cts = new CancellationTokenSource();
        _ = DoContinuousWorkAsync(work, onStateHasChanged, interval, _cts.Token);
    }

    // Overload for synchronous work
    public void Start(Action work, Action onStateHasChanged, TimeSpan interval)
    {
        Func<Task> asyncWork = () => {
            work();
            return Task.CompletedTask;
        };
        Start(asyncWork, onStateHasChanged, interval);
    }

    private async Task DoContinuousWorkAsync(Func<Task> work, Action onStateHasChanged, TimeSpan interval, CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            try
            {
                // 1. Do the developer's work.
                await work();

                // 2. THE FIX: Execute the "permission slip" (the callback)
                //    that the component gave us.
                onStateHasChanged?.Invoke();

                // 3. Wait for the interval.
                await Task.Delay(interval, token);
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in component background task: {ex.Message}");
            }
        }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
    }
}