@page "/file-reader"
@using System.IO
@using System.Text
@using System.Threading

@implements IDisposable

<h1>Real-time File Content Viewer</h1>

<p>
    <label for="filePath">File Path:</label>
    <input id="filePath" @bind="filePath" style="width: 500px;" />
</p>

<p>
    <label for="refreshInterval">Refresh Interval (ms):</label>
    <input id="refreshInterval" type="number" @bind="refreshInterval" />
</p>

<button class="btn btn-primary" @onclick="StartReading">Start Reading</button>
<button class="btn btn-secondary" @onclick="StopReading">Stop Reading</button>

<hr />

<h3>File Content:</h3>
<pre>@fileContent</pre>

@code {
    private string? filePath = "C:\\path\\to\\your\\file.txt"; // TODO: Change this to the path of the file you want to monitor.
    private int refreshInterval = 1000;
    private string? fileContent;
    private Timer? timer;

    private void StartReading()
    {
        timer?.Dispose();
        timer = new Timer(async _ => await ReadFile(), null, 0, refreshInterval);
    }

    private async Task ReadFile()
    {
        try
        {
            if (File.Exists(filePath))
            {
                // By using FileShare.ReadWrite, we can read the file even if it's currently being written to by another process.
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                {
                    fileContent = await streamReader.ReadToEndAsync();
                }
            }
            else
            {
                fileContent = "File not found.";
            }
        }
        catch (Exception ex)
        {
            fileContent = $"Error reading file: {ex.Message}";
        }

        // We are on a background thread, so we need to use InvokeAsync to update the UI. [2, 4, 9]
        await InvokeAsync(StateHasChanged);
    }

    private void StopReading()
    {
        timer?.Dispose();
    }

    public void Dispose()
    {
        timer?.Dispose();
    }
}