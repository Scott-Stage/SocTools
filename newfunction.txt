def compare_lists(my_software_list, db_software_list):
    """
    Compares lists including blacklist, user whitelist, vendor whitelist, stop words, and thresholds.
    """
    if my_software_list is None or db_software_list is None: return None

    # Prepare Database Data
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries (applying stop words)...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item)
    # ... (Debug print statements for DB/Lists/Stopwords) ...

    comparison_results = []
    processed_my_software_originals = set()
    print(f"\nComparing {len(my_software_list)} items from your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found', # Default
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': 1.1
        }
        if my_sw_orig in processed_my_software_originals: continue
        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}/{len(my_software_list)}): '{my_sw_orig}' ---")

        # --- Check Blacklist (Priority 1) ---
        if my_sw_orig in MANUAL_BLACKLIST_SET:
            result_entry['status'] = 'Not Found'; result_entry['reason'] = "Manual Blacklist"
            if DEBUG: print(f"  Classification: Not Found (Manual Blacklist)")
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue

        # --- Check User Whitelist (Priority 2) ---
        if my_sw_orig in MANUAL_USER_WHITELIST_SET:
            result_entry['status'] = 'Full Match'; result_entry['reason'] = "Manual Whitelist (User)"
            if DEBUG: print(f"  Classification: Full Match (Manual Whitelist User)")
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue

        # --- Check Vendor Whitelist (Priority 3) ---
        my_sw_orig_lower = my_sw_orig.lower() # Use lowercase version for checking
        vendor_found = None
        if DEBUG: print(f"  Checking for Vendors in: '{my_sw_orig_lower}'") # Added Debug
        for vendor in VENDOR_WHITELIST_SET:
            pattern = r'\b' + re.escape(vendor) + r'\b'
            try:
                 # Using re.IGNORECASE for extra safety, though should not be needed if list/input is lowercase
                 match = re.search(pattern, my_sw_orig_lower, re.IGNORECASE)
                 if DEBUG: print(f"    Checking Vendor: '{vendor}', Pattern: '{pattern}', Match: {bool(match)}") # Added Debug
                 if match:
                    vendor_found = vendor # Store the actual vendor found
                    break # Stop checking vendors once one is found
            except re.error as e:
                 print(f"Warning: Regex error checking vendor '{vendor}' against '{my_sw_orig_lower}': {e}")
                 continue
        if vendor_found:
            result_entry['status'] = 'Full Match'; result_entry['reason'] = f"Vendor Match ({vendor_found})"
            if DEBUG: print(f"  Classification: Full Match (Vendor Match '{vendor_found}' found)")
            comparison_results.append(result_entry)
            processed_my_software_originals.add(my_sw_orig)
            continue # IMPORTANT: Skip to next item in your list

        # --- Normalize & Compare (Only if not caught by lists above) ---
        # ... (Rest of the normalization and comparison logic remains exactly the same as the previous version) ...
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
             result_entry['status'] = 'Not Found'; result_entry['reason'] = "Input empty after stop words"
             if DEBUG: print(f"  Classification: Not Found (Empty Norm)")
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
             result_entry['status'] = 'Not Found'; result_entry['reason'] = "Input has no valid tokens"
             if DEBUG: print(f"  Classification: Not Found (No Tokens)")
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        found_direct_full_match = False
        potential_partial_details = []
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1;
            if not db_tokens: continue;
            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)
            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist; best_overall_candidate_norm = db_norm

            if sym_diff_len <= 1:
                result_entry['status'] = 'Full Match'; result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"; result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True; break

            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens"
            if partial_reason: potential_partial_details.append({'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason})

        # Final Classification (if comparison loop finished)
        if not found_direct_full_match:
            comparison_status = 'Not Found'; comparison_reason = None
            comparison_matched_db = None; comparison_jaccard = None
            comparison_all_partials = []

            if potential_partial_details:
                 best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
                 min_partial_jaccard = best_potential['jaccard']
                 best_partial_reason = best_potential['reason']
                 best_partial_db_norm = best_potential['db_norm']
                 best_match_orig_db_entries = db_normalized_map[best_partial_db_norm]
                 all_partial_db_origs_reporting = set()
                 for detail in potential_partial_details: all_partial_db_origs_reporting.update(db_normalized_map[detail['db_norm']])
                 comparison_all_partials = sorted(list(all_partial_db_origs_reporting))

                 if min_partial_jaccard >= JACCARD_NO_MATCH_THRESHOLD:
                      comparison_status = 'Not Found'
                      comparison_reason = f"Weak Partial (Min Jaccard={min_partial_jaccard:.2f} >= {JACCARD_NO_MATCH_THRESHOLD:.2f})"
                 elif min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD:
                      comparison_status = 'Full Match'
                      comparison_matched_db = best_match_orig_db_entries[0]
                      comparison_reason = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                      comparison_jaccard = min_partial_jaccard
                 else: # True Partial Match
                      comparison_status = 'Partial Match'
                      comparison_matched_db = best_match_orig_db_entries[0]
                      comparison_reason = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"
                      comparison_jaccard = min_partial_jaccard
            else: # No direct match, no potential partials
                 comparison_status = 'Not Found'
                 comparison_reason = "No match criteria met"

            # Update result entry with comparison outcome
            result_entry['status'] = comparison_status
            result_entry['reason'] = comparison_reason
            result_entry['matched_db_orig'] = comparison_matched_db
            result_entry['jaccard'] = comparison_jaccard
            result_entry['all_partial_db_matches'] = comparison_all_partials

        # Set nearest candidate info if final status is Not Found
        if result_entry['status'] == 'Not Found':
             if best_overall_candidate_norm:
                  result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                  result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                  current_reason = result_entry['reason']
                  if current_reason not in ["Manual Blacklist", "Input empty after stop words", "Input has no valid tokens"]:
                       reason_suffix = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                       if current_reason and "Weak Partial" in current_reason:
                            result_entry['reason'] = f"{current_reason} ({reason_suffix})"
                       elif current_reason == "No match criteria met":
                            result_entry['reason'] = reason_suffix
                       elif not current_reason:
                            result_entry['reason'] = reason_suffix
             elif result_entry['reason'] is None or result_entry['reason'] == "No match criteria met":
                  result_entry['reason'] = "No DB entries to compare"

        # Append final result for this item
        comparison_results.append(result_entry)
        # processed_my_software_originals.add(my_sw_orig) # Already added at start

    print("\nComparison complete.")
    return comparison_results