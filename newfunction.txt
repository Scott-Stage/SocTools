import os
import re
import string
import math # For infinity
import textwrap # Import for word wrapping

# --- Configuration ---
DEBUG = False # Set to True to see detailed comparison steps
JACCARD_PROMOTION_THRESHOLD = 0.5  # Threshold (0.0 to 1.0) for promoting partial to full (<= Threshold)
JACCARD_NO_MATCH_THRESHOLD = 0.85 # Threshold (0.0 to 1.0) for classifying weak partials as 'Not Found' (>= Threshold)

# --- Column Widths for Output Table ---
WIDTH_MY_SW = 40
WIDTH_MATCHED_COL = 40
WIDTH_REASON = 45 # Increased slightly for potentially longer reasons

def read_software_list(filepath):
    """Reads a software list from a file, one item per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

def normalize_name(name):
    """Normalizes software name."""
    if not name: return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator)
    name = name.lower().strip()
    name = re.sub(r'\s+', ' ', name)
    tokens = name.split()
    unique_sorted_tokens = sorted(list(set(filter(None, tokens))))
    if not unique_sorted_tokens: return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    """ Calculates Jaccard distance: len(symm_diff) / len(union) """
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0 # Sets are identical and empty
    # If union exists but sym_diff is empty, sets are identical, distance is 0
    return len(sym_diff) / len(union)


def compare_lists(my_software_list, db_software_list):
    """
    Compares lists with refined Full/Partial/Not Found match criteria.
    - Potential Partial: (Symm Diff == 2) OR (Proper subset, size >= 2).
    - Full Match: (Symm Diff <= 1) OR (Potential Partial AND Jaccard <= PROMOTION_THRESH).
    - Partial Match: Potential Partial AND PROMOTION_THRESH < Jaccard < NO_MATCH_THRESH.
    - Not Found: Not Full/Partial OR (Potential Partial AND Jaccard >= NO_MATCH_THRESH).
    """
    if my_software_list is None or db_software_list is None: return None

    # --- Prepare Database Data ---
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item)
    if DEBUG: print(f"Normalized DB forms: {list(db_token_sets.keys())}")

    # --- Initialize Results Storage ---
    comparison_results = []
    processed_my_software_originals = set()

    # --- Compare Each Item in My List ---
    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found',
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': 1.1 # Initialize high
        }
        if my_sw_orig in processed_my_software_originals: continue
        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}): '{my_sw_orig}' ---")
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
            result_entry['reason'] = "Input normalizes to empty"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
             result_entry['reason'] = "Input has no valid tokens"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        found_direct_full_match = False
        potential_partial_details = []
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        # --- Inner loop checking against DB ---
        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1
            if not db_tokens: continue
            if DEBUG: print(f"  Checking against DB entry {db_check_counter}: '{db_norm}' | Tokens: {db_tokens}")

            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)

            # Track nearest overall candidate regardless of match status
            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist
                 best_overall_candidate_norm = db_norm

            if DEBUG: print(f"    Symm Diff: {symmetric_difference} (Size: {sym_diff_len}) | Jaccard Dist: {jaccard_dist:.4f}")

            # Check for Direct Full Match (Priority 1)
            if sym_diff_len <= 1:
                if DEBUG: print(f"    --> Direct Full Match found (Symm Diff <= 1).")
                result_entry['status'] = 'Full Match'
                result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"
                result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True
                break # Highest priority match found

            # Check for Potential Partial Criteria
            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens" # Overwrites if both true

            if partial_reason:
                 potential_partial_details.append({
                     'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason
                 })
                 if DEBUG: print(f"    --> Recording potential Partial Match details (Reason: {partial_reason}, Jaccard: {jaccard_dist:.4f}, DB Norm: {db_norm}).")
            elif DEBUG: print(f"    --> No Full or Potential Partial match criteria met.")

        # --- Final Classification Logic (After checking all DB) ---
        if not found_direct_full_match:
            if potential_partial_details:
                # Found potential partials, analyze them
                best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
                min_partial_jaccard = best_potential['jaccard']
                best_partial_reason = best_potential['reason']
                best_partial_db_norm = best_potential['db_norm']

                all_partial_db_origs = set()
                for detail in potential_partial_details:
                    all_partial_db_origs.update(db_normalized_map[detail['db_norm']])
                result_entry['all_partial_db_matches'] = sorted(list(all_partial_db_origs))

                if DEBUG: print(f"  Potential partial matches found. Min Jaccard Distance: {min_partial_jaccard:.4f} (Reason: {best_partial_reason})")

                # Apply thresholds for final classification
                if min_partial_jaccard >= JACCARD_NO_MATCH_THRESHOLD:
                    result_entry['status'] = 'Not Found'
                    result_entry['reason'] = f"Weak Partial (Min Jaccard={min_partial_jaccard:.2f} >= {JACCARD_NO_MATCH_THRESHOLD:.2f})"
                    if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Not Found (Weak Partial)")
                elif min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD:
                    result_entry['status'] = 'Full Match'
                    result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Promoted)")
                else: # Falls between the thresholds
                    result_entry['status'] = 'Partial Match'
                    result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0] # Best match representative
                    result_entry['reason'] = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Partial Match")
            else:
                # No direct full match, no potential partials -> Not Found
                result_entry['status'] = 'Not Found'
                # Reason will be based on the overall nearest candidate found earlier
                if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Not Found (No criteria met)")
        elif DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Direct)")

        # Record nearest candidate details if status is 'Not Found'
        if result_entry['status'] == 'Not Found':
             if best_overall_candidate_norm:
                  result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                  result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                  # Append nearest info to reason if reason wasn't already set (e.g., weak partial)
                  if result_entry['reason'] is None or "Nearest" not in result_entry['reason']:
                       reason_suffix = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                       result_entry['reason'] = f"{result_entry['reason']} ({reason_suffix})" if result_entry['reason'] else reason_suffix
             elif result_entry['reason'] is None: # Should only happen if DB is empty
                  result_entry['reason'] = "No DB entries to compare"


        comparison_results.append(result_entry)
        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return comparison_results

def write_results_table(output_file, comparison_results):
    """Writes the categorized results to a file in table format with word wrap."""
    if comparison_results is None:
        print("Skipping writing results due to previous errors.")
        return

    full_matches = sorted([r for r in comparison_results if r['status'] == 'Full Match'], key=lambda x: x['my_sw_orig'])
    partial_matches = sorted([r for r in comparison_results if r['status'] == 'Partial Match'], key=lambda x: x['my_sw_orig'])
    not_found = sorted([r for r in comparison_results if r['status'] == 'Not Found'], key=lambda x: x['my_sw_orig'])

    def get_wrapped_lines(text, width, default="N/A"):
        if text is None: text = default
        return textwrap.wrap(text, width=width, initial_indent="", subsequent_indent="", drop_whitespace=True) or [default]

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("Software Comparison Results\n")
            # Adjust total width calculation if needed
            f.write("=" * (WIDTH_MY_SW + WIDTH_MATCHED_COL + WIDTH_REASON + 6) + "\n\n")

            # --- Full Matches Table ---
            f.write("=== Full Matches ===\n")
            f.write(f"    (Symm Diff <= 1 OR Potential Partial w/ Jaccard <= {JACCARD_PROMOTION_THRESHOLD:.2f})\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Matched DB Entry':<{WIDTH_MATCHED_COL}} | {'Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if full_matches:
                for item in full_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matched_db_lines = get_wrapped_lines(item['matched_db_orig'], WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matched_db_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matched_part = matched_db_lines[i] if i < len(matched_db_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matched_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- Partial Matches Table ---
            f.write("=== Partial Matches ===\n")
            f.write(f"    (Potential Partial AND {JACCARD_PROMOTION_THRESHOLD:.2f} < Jaccard < {JACCARD_NO_MATCH_THRESHOLD:.2f})\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Potential DB Matches':<{WIDTH_MATCHED_COL}} | {'Best Match Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if partial_matches:
                for item in partial_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matches_str = (', '.join(item['all_partial_db_matches']) if item['all_partial_db_matches'] else "N/A")
                    matches_lines = get_wrapped_lines(matches_str, WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matches_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matches_part = matches_lines[i] if i < len(matches_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matches_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- No Matches Table ---
            f.write("=== No Matches Found ===\n")
            f.write(f"    (Not Full/Partial OR Potential Partial w/ Jaccard >= {JACCARD_NO_MATCH_THRESHOLD:.2f})\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Nearest DB Candidate':<{WIDTH_MATCHED_COL}} | {'Reason / Nearest':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if not_found:
                for item in not_found:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    nearest_lines = get_wrapped_lines(item['nearest_candidate_orig'], WIDTH_MATCHED_COL, default="None")
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(nearest_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        nearest_part = nearest_lines[i] if i < len(nearest_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {nearest_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")

    except Exception as e:
        print(f"Error writing results table to file {output_file}: {e}")


# --- Main Execution ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results_table.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print(f"Comparing lists (Jaccard Promotion Thresh: {JACCARD_PROMOTION_THRESHOLD}, No Match Thresh: {JACCARD_NO_MATCH_THRESHOLD})...")
        detailed_results = compare_lists(my_list, db_list)
        write_results_table(output_result_file, detailed_results)
    else:
        print("Comparison cancelled due to errors reading input files.")