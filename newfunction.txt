Alright — let’s build you a **working dynamic MudDrop dashboard** where users can add `<SocPcInfoComponent>` blocks and drag them around.

I’ll break it into **3 parts**:

1. **Data model** for dashboard items
2. **Dashboard page** with `MudDropContainer`
3. **Component rendering (`SocPcInfoComponent`)**

---

## 1️⃣ Data Model — `DashboardItem.cs`

```csharp
public class DashboardItem
{
    public string Id { get; set; }           // Unique ID for tracking order
    public string Title { get; set; }        // Optional display name
    public Type ComponentType { get; set; }  // Component to render
    public Dictionary<string, object> Parameters { get; set; } = new();
}
```

---

## 2️⃣ Dashboard Page — `Dashboard.razor`

```razor
@page "/dashboard"
@using MudBlazor
@using MudBlazor.Utilities
@using YourAppNamespace.Components  <!-- Namespace where SocPcInfoComponent lives -->

<MudContainer MaxWidth="false">
    <MudPaper Class="pa-4">
        <MudButton Variant="Filled" Color="Primary" OnClick="AddDevice">
            Add Device
        </MudButton>

        <MudDropContainer Items="@dashboardItems"
                          ItemDropped="@(dropInfo => OnItemDropped(dropInfo))"
                          RowSpacing="20"
                          ColumnSpacing="20"
                          ItemsPerRow="3">
            <ItemTemplate Context="item">
                <MudPaper Class="pa-4">
                    <DynamicComponent Type="@item.ComponentType" Parameters="@item.Parameters" />
                </MudPaper>
            </ItemTemplate>
        </MudDropContainer>
    </MudPaper>
</MudContainer>

@code {
    private List<DashboardItem> dashboardItems = new();

    private void AddDevice()
    {
        dashboardItems.Add(new DashboardItem
        {
            Id = Guid.NewGuid().ToString(),
            Title = "Device Info",
            ComponentType = typeof(SocPcInfoComponent),
            Parameters = new Dictionary<string, object>
            {
                { "DeviceId", Guid.NewGuid().ToString() } // Pass device-specific data
            }
        });
    }

    private void OnItemDropped(MudItemDropInfo<DashboardItem> dropInfo)
    {
        // Simple reorder logic
        var item = dropInfo.Item;
        dashboardItems.Remove(item);
        dashboardItems.Insert(dropInfo.Index, item);
    }
}
```

---

## 3️⃣ Example Device Component — `SocPcInfoComponent.razor`

```razor
@code {
    [Parameter] public string DeviceId { get; set; }

    private string status;
    private string hostName;

    protected override async Task OnInitializedAsync()
    {
        // Simulate loading device data from your PowerShell service
        await Task.Delay(300); 
        status = "Online";
        hostName = $"Host-{DeviceId[..5]}";
    }
}

<MudPaper Class="pa-3">
    <MudText Typo="Typo.h6">@hostName</MudText>
    <MudText>Status: @status</MudText>
</MudPaper>
```

---

✅ **How it works:**

* Clicking **"Add Device"** adds a new `SocPcInfoComponent` to the list.
* The `DynamicComponent` renders it, passing a `DeviceId` parameter.
* You can drag and drop items inside the `MudDropContainer` to reorder.

---

If you want, I can extend this so that:

* The layout **persists** to local storage or a database
* `SocPcInfoComponent` actually calls your **PowerShell service** and shows real data
* Users can **remove** dashboard items

Do you want me to make it persistent and wired to your PowerShell data next?
