import os
import re
import string
import math # For infinity
import textwrap # Import for word wrapping

# --- Configuration ---
DEBUG = False # Set to True to see detailed comparison steps
JACCARD_PROMOTION_THRESHOLD = 0.5  # Threshold (0.0 to 1.0) for promoting partial to full (<= Threshold)
JACCARD_NO_MATCH_THRESHOLD = 0.85 # Threshold (0.0 to 1.0) for classifying weak partials as 'Not Found' (>= Threshold)

# --- Manual User Whitelist (Your Software Entries) ---
# Any *exact entry* from your software list found here will be forced to 'Full Match'.
# This check happens *after* the blacklist.
MANUAL_USER_WHITELIST = [
    "Google Chrome", # Exact match needed
    "Specific Internal Tool v3.0",
]
MANUAL_USER_WHITELIST_SET = set(MANUAL_USER_WHITELIST)

# --- Manual Blacklist (Your Software Entries) ---
# Any *exact entry* from your software list found here will be forced to 'Not Found'.
# This check happens *first*.
MANUAL_BLACKLIST = [
    "Known Problematic Software Entry",
    "Ignore This Specific Version",
]
MANUAL_BLACKLIST_SET = set(MANUAL_BLACKLIST)

# --- Stop Words ---
# These words will be removed during normalization *before* comparison.
STOP_WORDS = [
    'a', 'an', 'and', 'the', 'of', 'in', 'on', 'at', 'to', 'for', 'with',
    'server', 'client', 'manager', 'utility', 'agent', 'service',
    'enterprise', 'professional', 'edition', 'version',
    'v', 'r', 'x', # Added 'x' as common suffix
    # Add more common/non-discriminating words here
]
STOP_WORDS_SET = set(STOP_WORDS)

# --- Vendor Whitelist ---
# If an item *not already a Full Match* contains one of these vendors (case-insensitive), promote to Full Match.
VENDOR_WHITELIST = [
    "google",
    "microsoft",
    "oracle",
    "adobe",
    "apple",
    "cisco",
    "vmware",
    # Add more single-word vendor names (lowercase)
]
VENDOR_WHITELIST_SET = set(VENDOR_WHITELIST) # Set for efficiency


# --- Column Widths for Output Table ---
WIDTH_MY_SW = 40
WIDTH_MATCHED_COL = 40
WIDTH_REASON = 50

# --- Function Definitions (read_software_list, calculate_jaccard_distance - unchanged) ---
def read_software_list(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}"); return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}"); return None

def normalize_name(name):
    """Normalizes software name including stop word removal."""
    if not name: return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator).lower().strip()
    name = re.sub(r'\s+', ' ', name)
    tokens = [token for token in name.split() if token not in STOP_WORDS_SET]
    unique_sorted_tokens = sorted(list(set(filter(None, tokens))))
    if not unique_sorted_tokens: return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0
    return len(sym_diff) / len(union)
# --- End unchanged functions ---

def compare_lists(my_software_list, db_software_list):
    """
    Compares lists including blacklist, user whitelist, vendor whitelist, stop words, and thresholds.
    """
    if my_software_list is None or db_software_list is None: return None

    # Prepare Database Data
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries (applying stop words)...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item)
    # ... (Debug print statements) ...

    comparison_results = []
    processed_my_software_originals = set()

    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found', # Default
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': 1.1
        }
        if my_sw_orig in processed_my_software_originals: continue
        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}): '{my_sw_orig}' ---")

        # --- Check Blacklist (Priority 1) ---
        if my_sw_orig in MANUAL_BLACKLIST_SET:
            if DEBUG: print(f"  Item is on Manual Blacklist.")
            result_entry['status'] = 'Not Found'; result_entry['reason'] = "Manual Blacklist"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue

        # --- Check User Whitelist (Priority 2) ---
        if my_sw_orig in MANUAL_USER_WHITELIST_SET:
            if DEBUG: print(f"  Item is on Manual User Whitelist.")
            result_entry['status'] = 'Full Match'; result_entry['reason'] = "Manual Whitelist (User)"
            # Optionally find nearest DB match just for display, but status is set
            # (Skipping nearest find for whitelist for simplicity now)
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue

        # --- Normalize User SW (applying stop words) ---
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
             result_entry['status'] = 'Not Found'; result_entry['reason'] = "Input empty after stop words"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
             result_entry['status'] = 'Not Found'; result_entry['reason'] = "Input has no valid tokens"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        # --- Comparison Logic ---
        found_direct_full_match = False
        potential_partial_details = []
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        # Inner loop checking against DB
        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1;
            if not db_tokens: continue;
            # ... (Debug print checking against DB) ...

            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)

            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist; best_overall_candidate_norm = db_norm
            # ... (Debug print Symm Diff / Jaccard) ...

            # Check Direct Full Match (Priority 3)
            if sym_diff_len <= 1:
                # ... (Handle Direct Full Match - unchanged) ...
                result_entry['status'] = 'Full Match'; result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"; result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True; break

            # Check Potential Partial Criteria
            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens"

            if partial_reason:
                 potential_partial_details.append({'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason})
                 # ... (Debug print recording potential partial) ...
            # ... (Debug print no match criteria met) ...

        # --- Final Classification Logic (After checking all DB) ---
        initial_status = 'Not Found' # Status based *only* on comparison loop
        best_match_orig_db_entries = None # Store original DB entries of best partial match

        if found_direct_full_match:
             initial_status = 'Full Match'
             # Reason, matched_db_orig, etc. already set in the loop
             if DEBUG: print(f"  Initial Status: Full Match (Direct)")

        elif potential_partial_details:
             best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
             min_partial_jaccard = best_potential['jaccard']
             best_partial_reason = best_potential['reason']
             best_partial_db_norm = best_potential['db_norm']
             best_match_orig_db_entries = db_normalized_map[best_partial_db_norm] # Store for potential use

             all_partial_db_origs_reporting = set()
             for detail in potential_partial_details: all_partial_db_origs_reporting.update(db_normalized_map[detail['db_norm']])
             result_entry['all_partial_db_matches'] = sorted(list(all_partial_db_origs_reporting))

             if DEBUG: print(f"  Potential partial matches found. Min Jaccard: {min_partial_jaccard:.4f}")

             # Apply thresholds
             if min_partial_jaccard >= JACCARD_NO_MATCH_THRESHOLD:
                  initial_status = 'Not Found'
                  result_entry['reason'] = f"Weak Partial (Min Jaccard={min_partial_jaccard:.2f} >= {JACCARD_NO_MATCH_THRESHOLD:.2f})"
                  if DEBUG: print(f"  Initial Status: Not Found (Weak Partial)")
             elif min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD:
                  initial_status = 'Full Match'
                  result_entry['matched_db_orig'] = best_match_orig_db_entries[0]
                  result_entry['reason'] = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                  result_entry['jaccard'] = min_partial_jaccard
                  if DEBUG: print(f"  Initial Status: Full Match (Promoted)")
             else: # True Partial Match (between thresholds)
                  initial_status = 'Partial Match'
                  result_entry['matched_db_orig'] = best_match_orig_db_entries[0]
                  result_entry['reason'] = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"
                  result_entry['jaccard'] = min_partial_jaccard
                  if DEBUG: print(f"  Initial Status: Partial Match")
        else: # No direct match, no potential partials
             initial_status = 'Not Found'
             if DEBUG: print(f"  Initial Status: Not Found (No criteria met)")

        # --- Apply Vendor Whitelist Promotion (Priority 4) ---
        # Only applies if not already a Full Match from comparison logic
        promoted_by_vendor = False
        if initial_status != 'Full Match':
            my_sw_orig_lower = my_sw_orig.lower() # Case-insensitive check
            for vendor in VENDOR_WHITELIST_SET:
                # Check if vendor word appears in the original string
                # Using regex for word boundaries might be more robust: r'\b' + re.escape(vendor) + r'\b'
                # Simple 'in' check for now:
                if vendor in my_sw_orig_lower:
                    # Check if it's just a substring or a whole word match (basic check)
                    # This helps avoid matching 'oracle' in 'doracle' slightly better than pure 'in'
                    pattern = r'\b' + re.escape(vendor) + r'\b'
                    if re.search(pattern, my_sw_orig_lower):
                        if DEBUG: print(f"  Vendor '{vendor}' found in '{my_sw_orig}'. Promoting.")
                        result_entry['status'] = 'Full Match'
                        # Decide what reason to show - prioritize vendor match
                        original_reason = result_entry['reason'] # Capture reason from partial/not found state
                        result_entry['reason'] = f"Vendor Match ({vendor})"
                        if original_reason and original_reason != "Weak Partial" and not original_reason.startswith("Nearest"): # Append previous reason if relevant
                           result_entry['reason'] += f" (was {original_reason})"

                        # Clear fields that might have been set by partial/not found status
                        result_entry['matched_db_orig'] = None # Or keep best partial? Let's clear.
                        result_entry['jaccard'] = None
                        result_entry['all_partial_db_matches'] = []
                        result_entry['nearest_candidate_orig'] = None
                        result_entry['nearest_candidate_jaccard'] = None
                        promoted_by_vendor = True
                        break # Stop checking vendors once one is found
        else:
            result_entry['status'] = initial_status # Keep the Full Match status from comparison

        if not promoted_by_vendor and result_entry['status'] == 'Not Found':
             # Set nearest candidate info only if final status is Not Found
             if best_overall_candidate_norm:
                  result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                  result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                  current_reason = result_entry['reason']
                  # Append nearest info if reason isn't already specific like Blacklist/Empty/Weak Partial
                  if current_reason not in ["Manual Blacklist", "Input empty after stop words", "Input has no valid tokens"] and not (current_reason and "Weak Partial" in current_reason):
                       reason_suffix = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                       result_entry['reason'] = reason_suffix
                  elif current_reason and "Weak Partial" in current_reason:
                      result_entry['reason'] += f" (Nearest Jaccard={min_overall_jaccard:.2f})"

             elif result_entry['reason'] is None:
                  result_entry['reason'] = "No DB entries to compare"


        # Ensure status is set if somehow missed (shouldn't happen)
        if 'status' not in result_entry:
             result_entry['status'] = initial_status if initial_status else 'Not Found'

        # Append final result for this item
        comparison_results.append(result_entry)
        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return comparison_results


# --- Function Definition write_results_table (unchanged formatting logic, updated headers) ---
def write_results_table(output_file, comparison_results):
    if comparison_results is None:
        print("Skipping writing results due to previous errors."); return

    full_matches = sorted([r for r in comparison_results if r['status'] == 'Full Match'], key=lambda x: x['my_sw_orig'])
    partial_matches = sorted([r for r in comparison_results if r['status'] == 'Partial Match'], key=lambda x: x['my_sw_orig'])
    not_found = sorted([r for r in comparison_results if r['status'] == 'Not Found'], key=lambda x: x['my_sw_orig'])

    def get_wrapped_lines(text, width, default="N/A"):
        if text is None: text = default
        text_str = str(text)
        return textwrap.wrap(text_str, width=width, initial_indent="", subsequent_indent="", drop_whitespace=True) or [default]

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("Software Comparison Results\n")
            f.write("=" * (WIDTH_MY_SW + WIDTH_MATCHED_COL + WIDTH_REASON + 6) + "\n\n")

            # Full Matches Table
            f.write("=== Full Matches ===\n")
            f.write(f"    (Manual Whitelist OR Vendor Match OR Symm Diff <= 1 OR Promoted Partial [Jaccard <= {JACCARD_PROMOTION_THRESHOLD:.2f}])\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Matched DB Entry':<{WIDTH_MATCHED_COL}} | {'Reason':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if full_matches:
                for item in full_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    # Matched DB might be None for Manual Whitelist or Vendor Match
                    matched_db_lines = get_wrapped_lines(item['matched_db_orig'], WIDTH_MATCHED_COL, default="")
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matched_db_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matched_part = matched_db_lines[i] if i < len(matched_db_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matched_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

            # Partial Matches Table
            f.write("=== Partial Matches ===\n")
            f.write(f"    (Potential Partial AND {JACCARD_PROMOTION_THRESHOLD:.2f} < Jaccard < {JACCARD_NO_MATCH_THRESHOLD:.2f} AND Not Whitelisted/Vendor)\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Potential DB Matches':<{WIDTH_MATCHED_COL}} | {'Best Match Reason':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if partial_matches:
                for item in partial_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matches_str = (', '.join(item['all_partial_db_matches']) if item['all_partial_db_matches'] else "N/A")
                    matches_lines = get_wrapped_lines(matches_str, WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matches_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matches_part = matches_lines[i] if i < len(matches_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matches_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

            # No Matches Table
            f.write("=== No Matches Found ===\n")
            f.write(f"    (Manual Blacklist OR Not Full/Partial OR Weak Partial [Jaccard >= {JACCARD_NO_MATCH_THRESHOLD:.2f}])\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Nearest DB Candidate':<{WIDTH_MATCHED_COL}} | {'Reason / Nearest':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if not_found:
                for item in not_found:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    nearest_lines = get_wrapped_lines(item['nearest_candidate_orig'], WIDTH_MATCHED_COL, default="None")
                    reason_str = str(item.get('reason', "N/A"))
                    reason_lines = get_wrapped_lines(reason_str, WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(nearest_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        nearest_part = nearest_lines[i] if i < len(nearest_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {nearest_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")
    except Exception as e:
        print(f"Error writing results table to file {output_file}: {e}")
# --- End write_results_table ---


# --- Main Execution (unchanged) ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results_table.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print(f"Comparing lists (Jaccard Promo Thresh: {JACCARD_PROMOTION_THRESHOLD}, No Match Thresh: {JACCARD_NO_MATCH_THRESHOLD})...")
        detailed_results = compare_lists(my_list, db_list)
        write_results_table(output_result_file, detailed_results)
    else:
        print("Comparison cancelled due to errors reading input files.")