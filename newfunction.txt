import os
import re
import string
import math # For infinity
import textwrap # Import for word wrapping

# --- Configuration ---
DEBUG = False # Set to True to see detailed comparison steps
JACCARD_PROMOTION_THRESHOLD = 0.5  # Threshold (0.0 to 1.0) for promoting partial to full (<= Threshold)
JACCARD_NO_MATCH_THRESHOLD = 0.85 # Threshold (0.0 to 1.0) for classifying weak partials as 'Not Found' (>= Threshold)

# --- Manual Whitelist (DB Entries) ---
# If the *best* partial match found (lowest Jaccard) involves one of these *exact DB entries*, promote to Full Match.
MANUAL_WHITELIST = [
    "Example Whitelisted DB Entry v1",
    "Another Critical DB Software Name",
]
MANUAL_WHITELIST_SET = set(MANUAL_WHITELIST)

# --- Manual Blacklist (Your Software Entries) ---
MANUAL_BLACKLIST = [
    "Known Problematic Software Entry",
    "Ignore This Specific Version",
]
MANUAL_BLACKLIST_SET = set(MANUAL_BLACKLIST)

# --- Stop Words ---
STOP_WORDS = [
    'a', 'an', 'and', 'the', 'of', 'in', 'on', 'at', 'to', 'for', 'with',
    'server', 'client', 'manager', 'utility', 'agent', 'service',
    'enterprise', 'professional', 'edition', 'version',
    'v', 'r',
]
STOP_WORDS_SET = set(STOP_WORDS)

# --- Column Widths for Output Table ---
WIDTH_MY_SW = 40
WIDTH_MATCHED_COL = 40
WIDTH_REASON = 50

# --- Function Definitions (read_software_list, normalize_name, calculate_jaccard_distance - unchanged) ---
def read_software_list(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}"); return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}"); return None

def normalize_name(name):
    if not name: return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator).lower().strip()
    name = re.sub(r'\s+', ' ', name)
    tokens = [token for token in name.split() if token not in STOP_WORDS_SET]
    unique_sorted_tokens = sorted(list(set(filter(None, tokens))))
    if not unique_sorted_tokens: return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0
    return len(sym_diff) / len(union)
# --- End unchanged functions ---

def compare_lists(my_software_list, db_software_list):
    """
    Compares lists including blacklist, stop words, whitelist, and thresholds.
    Whitelist promotion now only applies if the *best* partial match DB entry is whitelisted.
    """
    if my_software_list is None or db_software_list is None: return None

    # Prepare Database Data
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries (applying stop words)...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item) # Store original
    # ... (Debug print statements) ...

    comparison_results = []
    processed_my_software_originals = set()

    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found',
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': 1.1
        }
        if my_sw_orig in processed_my_software_originals: continue
        # ... (Debug print for start of comparison) ...

        # Check Blacklist FIRST
        if my_sw_orig in MANUAL_BLACKLIST_SET:
            # ... (Handle Blacklist - unchanged) ...
            result_entry['status'] = 'Not Found'; result_entry['reason'] = "Manual Blacklist"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue

        # Normalize user software
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
            # ... (Handle empty normalization - unchanged) ...
            result_entry['reason'] = "Input empty after stop words"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
            # ... (Handle no valid tokens - unchanged) ...
             result_entry['reason'] = "Input has no valid tokens"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        # ... (Debug print for normalized user sw) ...

        found_direct_full_match = False
        potential_partial_details = [] # Stores {'jaccard': ..., 'db_norm': ..., 'reason': ...}
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        # Inner loop checking against DB
        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1;
            if not db_tokens: continue;
            # ... (Debug print checking against DB) ...

            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)

            # Track nearest overall
            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist; best_overall_candidate_norm = db_norm
            # ... (Debug print Symm Diff / Jaccard) ...

            # Check Direct Full Match
            if sym_diff_len <= 1:
                # ... (Handle Direct Full Match - unchanged) ...
                result_entry['status'] = 'Full Match'; result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"; result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True; break

            # Check Potential Partial Criteria
            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens"

            if partial_reason:
                 # Record details if potential partial criteria met
                 potential_partial_details.append({
                     'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason
                 })
                 # ... (Debug print recording potential partial) ...
            # ... (Debug print no match criteria met) ...

        # --- Final Classification Logic ---
        if not found_direct_full_match:
            if potential_partial_details:
                # --- Analyze Potential Partials ---
                best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
                min_partial_jaccard = best_potential['jaccard']
                best_partial_reason = best_potential['reason']
                best_partial_db_norm = best_potential['db_norm']

                # Get the original DB entries *specifically for the best potential match*
                best_match_orig_db_entries = db_normalized_map[best_partial_db_norm]

                # *** CORRECTED WHITELIST CHECK ***
                # Check if any of the original DB entries *for the best match* are whitelisted
                is_best_match_whitelisted = any(db_orig in MANUAL_WHITELIST_SET for db_orig in best_match_orig_db_entries)

                # Collect all original DB names involved in ANY potential partial match *only for reporting*
                all_partial_db_origs_reporting = set()
                for detail in potential_partial_details:
                    all_partial_db_origs_reporting.update(db_normalized_map[detail['db_norm']])
                result_entry['all_partial_db_matches'] = sorted(list(all_partial_db_origs_reporting))

                if DEBUG: print(f"  Potential partial matches found. Min Jaccard: {min_partial_jaccard:.4f}. Best match whitelisted: {is_best_match_whitelisted}")

                # --- Apply Classification Rules ---
                if is_best_match_whitelisted: # Corrected Whitelist promotion
                    result_entry['status'] = 'Full Match'
                    result_entry['matched_db_orig'] = best_match_orig_db_entries[0] # Use first original of best match
                    result_entry['reason'] = f"Manual Whitelist ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Full Match (Manual Whitelist)")
                elif min_partial_jaccard >= JACCARD_NO_MATCH_THRESHOLD:
                    result_entry['status'] = 'Not Found'
                    result_entry['reason'] = f"Weak Partial (Min Jaccard={min_partial_jaccard:.2f} >= {JACCARD_NO_MATCH_THRESHOLD:.2f})"
                    if DEBUG: print(f"  FINAL Classification: Not Found (Weak Partial)")
                elif min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD:
                    result_entry['status'] = 'Full Match'
                    result_entry['matched_db_orig'] = best_match_orig_db_entries[0]
                    result_entry['reason'] = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Full Match (Promoted)")
                else: # It's a true Partial Match
                    result_entry['status'] = 'Partial Match'
                    result_entry['matched_db_orig'] = best_match_orig_db_entries[0]
                    result_entry['reason'] = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Partial Match")
            else: # No direct match, no potential partials
                result_entry['status'] = 'Not Found'
                if DEBUG: print(f"  FINAL Classification: Not Found (No criteria met)")
        elif DEBUG: print(f"  FINAL Classification: Full Match (Direct)")

        # Set nearest candidate info if classified as Not Found
        if result_entry['status'] == 'Not Found':
             if best_overall_candidate_norm:
                  result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                  result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                  current_reason = result_entry['reason']
                  if current_reason not in ["Manual Blacklist", "Input empty after stop words", "Input has no valid tokens"]:
                       reason_suffix = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                       if current_reason and "Weak Partial" in current_reason:
                            result_entry['reason'] = f"{current_reason} (Nearest Jaccard={min_overall_jaccard:.2f})"
                       else:
                            result_entry['reason'] = reason_suffix
             elif result_entry['reason'] is None:
                  result_entry['reason'] = "No DB entries to compare"

        comparison_results.append(result_entry)
        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return comparison_results

# --- Function Definition write_results_table (unchanged) ---
def write_results_table(output_file, comparison_results):
    if comparison_results is None:
        print("Skipping writing results due to previous errors."); return

    full_matches = sorted([r for r in comparison_results if r['status'] == 'Full Match'], key=lambda x: x['my_sw_orig'])
    partial_matches = sorted([r for r in comparison_results if r['status'] == 'Partial Match'], key=lambda x: x['my_sw_orig'])
    not_found = sorted([r for r in comparison_results if r['status'] == 'Not Found'], key=lambda x: x['my_sw_orig'])

    def get_wrapped_lines(text, width, default="N/A"):
        if text is None: text = default
        text_str = str(text)
        return textwrap.wrap(text_str, width=width, initial_indent="", subsequent_indent="", drop_whitespace=True) or [default]

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("Software Comparison Results\n")
            f.write("=" * (WIDTH_MY_SW + WIDTH_MATCHED_COL + WIDTH_REASON + 6) + "\n\n")

            # Full Matches Table
            f.write("=== Full Matches ===\n")
            f.write(f"    (Symm Diff <= 1 OR Whitelisted Best Partial OR Promoted Partial [Jaccard <= {JACCARD_PROMOTION_THRESHOLD:.2f}])\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Matched DB Entry':<{WIDTH_MATCHED_COL}} | {'Reason':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if full_matches:
                for item in full_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matched_db_lines = get_wrapped_lines(item['matched_db_orig'], WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matched_db_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matched_part = matched_db_lines[i] if i < len(matched_db_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matched_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

            # Partial Matches Table
            f.write("=== Partial Matches ===\n")
            f.write(f"    (Potential Partial AND {JACCARD_PROMOTION_THRESHOLD:.2f} < Jaccard < {JACCARD_NO_MATCH_THRESHOLD:.2f} AND Best Match Not Whitelisted)\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Potential DB Matches':<{WIDTH_MATCHED_COL}} | {'Best Match Reason':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if partial_matches:
                for item in partial_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matches_str = (', '.join(item['all_partial_db_matches']) if item['all_partial_db_matches'] else "N/A")
                    matches_lines = get_wrapped_lines(matches_str, WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matches_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matches_part = matches_lines[i] if i < len(matches_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matches_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

            # No Matches Table
            f.write("=== No Matches Found ===\n")
            f.write(f"    (Manual Blacklist OR Not Full/Partial OR Weak Partial [Jaccard >= {JACCARD_NO_MATCH_THRESHOLD:.2f}])\n") # Header updated
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Nearest DB Candidate':<{WIDTH_MATCHED_COL}} | {'Reason / Nearest':<{WIDTH_REASON}}"
            f.write(header + "\n"); f.write("-" * len(header) + "\n")
            if not_found:
                for item in not_found:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    nearest_lines = get_wrapped_lines(item['nearest_candidate_orig'], WIDTH_MATCHED_COL, default="None")
                    reason_str = str(item.get('reason', "N/A"))
                    reason_lines = get_wrapped_lines(reason_str, WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(nearest_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        nearest_part = nearest_lines[i] if i < len(nearest_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {nearest_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else: f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")
    except Exception as e:
        print(f"Error writing results table to file {output_file}: {e}")
# --- End unchanged write_results_table ---

# --- Main Execution (unchanged) ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results_table.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print(f"Comparing lists (Jaccard Promo Thresh: {JACCARD_PROMOTION_THRESHOLD}, No Match Thresh: {JACCARD_NO_MATCH_THRESHOLD})...")
        detailed_results = compare_lists(my_list, db_list)
        write_results_table(output_result_file, detailed_results)
    else:
        print("Comparison cancelled due to errors reading input files.")