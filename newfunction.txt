// Services/ComponentTaskRunner.cs
public class ComponentTaskRunner : IDisposable
{
    private CancellationTokenSource? _cts;

    public void Start(TimeSpan interval, Action onStateHasChanged, params Func<Task>[] workFunctions)
    {
        if (workFunctions == null || workFunctions.Length == 0) return;

        _cts = new CancellationTokenSource();
        _ = DoContinuousWorkAsync(interval, onStateHasChanged, workFunctions, _cts.Token);
    }

    private async Task DoContinuousWorkAsync(TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            try
            {
                // *** THE FIREWALL ***
                // We now explicitly run all the user's work on a background thread pool thread.
                // This guarantees that even a blocking call like Thread.Sleep() inside
                // one of the workFunctions will not freeze the UI.
                await Task.Run(async () =>
                {
                    foreach (var work in workFunctions)
                    {
                        if (token.IsCancellationRequested) break;
                        await work();
                    }
                }, token); // Pass the token to Task.Run as well.


                // After all the background work is done, we safely update the UI.
                if (!token.IsCancellationRequested)
                {
                    onStateHasChanged?.Invoke();
                }

                // Wait for the next interval.
                await Task.Delay(interval, token);
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in component background task: {ex.Message}");
            }
        }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
    }
}