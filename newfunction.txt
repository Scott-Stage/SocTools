// Services/ComponentTaskRunner.cs
using System.Collections.Concurrent;
using System.Threading;

// A private record to hold the full state for each managed task.
file record TaskState(CancellationTokenSource Cts, SemaphoreSlim Lock);

public class ComponentTaskRunner : IDisposable
{
    private readonly ConcurrentDictionary<string, TaskState> _runningTasks = new();

    public void Start(
        string taskName,
        TimeSpan interval,
        int maxConcurrency, // e.g., 1 for "skip if busy", >1 for throttling
        Action onStateHasChanged,
        params Func<Task>[] workFunctions)
    {
        var newState = new TaskState(
            new CancellationTokenSource(),
            new SemaphoreSlim(Math.Max(1, maxConcurrency))
        );

        if (!_runningTasks.TryAdd(taskName, newState))
        {
            newState.Cts.Dispose();
            newState.Lock.Dispose();
            return;
        }

        _ = DoContinuousWorkAsync(taskName, interval, onStateHasChanged, workFunctions, newState);
    }

    public void Stop(string taskName)
    {
        if (_runningTasks.TryRemove(taskName, out var taskState))
        {
            taskState.Cts.Cancel();
            taskState.Cts.Dispose();
            taskState.Lock.Dispose();
        }
    }

    // --- The Corrected StopAll Implementation ---
    public void StopAll()
    {
        // Take a snapshot of the keys because the collection will be modified
        // by the Stop() method during iteration.
        var taskNames = _runningTasks.Keys.ToList();
        
        foreach (var taskName in taskNames)
        {
            Stop(taskName);
        }
    }

    public bool IsRunning(string taskName)
    {
        return _runningTasks.ContainsKey(taskName);
    }

    private async Task DoContinuousWorkAsync(string taskName, TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, TaskState taskState)
    {
        while (!taskState.Cts.IsCancellationRequested)
        {
            try { await Task.Delay(interval, taskState.Cts.Token); }
            catch (OperationCanceledException) { break; }

            // Use a timeout of 0 on the semaphore to "skip if busy".
            // To allow queueing, you would remove the timeout.
            if (!await taskState.Lock.WaitAsync(0, taskState.Cts.Token))
            {
                Console.WriteLine($"Skipping tick for task '{taskName}' because it is already at max concurrency.");
                continue;
            }

            try
            {
                await Task.Run(async () =>
                {
                    foreach (var work in workFunctions)
                    {
                        if (taskState.Cts.IsCancellationRequested) break;
                        await work();
                    }
                }, taskState.Cts.Token);

                if (!taskState.Cts.IsCancellationRequested)
                {
                    onStateHasChanged?.Invoke();
                }
            }
            catch (OperationCanceledException) { /* This is expected on stop */ }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in background task '{taskName}': {ex.Message}");
            }
            finally
            {
                taskState.Lock.Release();
            }
        }
    }

    // --- The Dispose method correctly uses StopAll ---
    public void Dispose()
    {
        StopAll();
    }
}