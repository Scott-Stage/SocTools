Example in your context
Right now your PowerShell JSON looks like:

json
Copy
Edit
{
  "action": "GetSocPcInfo",
  "success": true,
  "output": {
    "PC-1": { "computername": "PC-1", "currentuser": "User1" },
    "PC-2": { "computername": "PC-2", "currentuser": "User2" }
  }
}
If you wanted to skip the dictionary step and deserialize straight into a class that has an Output property, you could do:

csharp
Copy
Edit
public class PowerShellResponse<T>
{
    [JsonPropertyName("action")]
    public string Action { get; set; }

    [JsonPropertyName("success")]
    public bool Success { get; set; }

    [JsonPropertyName("output")]
    public Dictionary<string, T> Output { get; set; }
}
Then your T could be your actual device model:

csharp
Copy
Edit
public class DeviceModel
{
    [JsonPropertyName("computername")]
    public string ComputerName { get; set; }

    [JsonPropertyName("currentuser")]
    public string CurrentUser { get; set; }

    [JsonPropertyName("manufacturer")]
    public string Manufacturer { get; set; }

    [JsonPropertyName("lastreboot")]
    public DateTime LastReboot { get; set; }

    [JsonPropertyName("drivesize")]
    public double DriveSize { get; set; }

    [JsonPropertyName("freespace")]
    public double FreeSpace { get; set; }
}
Deserialization now becomes:
csharp
Copy
Edit
var psResponse = JsonSerializer.Deserialize<PowerShellResponse<DeviceModel>>(jsonString);

// Access strongly-typed devices directly
var devices = psResponse.Output.Values.OrderBy(d => d.ComputerName).ToList();