Excellent question. In a .NET 8 Blazor Web App, the term "best way" requires careful consideration of the new rendering modes. Since a component can be rendered statically on the server, interactively on the server (via a circuit), or interactively on the client (WebAssembly), the solution needs to be robust and adaptable.

The core challenge is that sessionStorage is a browser-only feature. A component running on the server (whether for static SSR or an interactive circuit) has no direct access to it. Therefore, JavaScript Interop is required.

The best way to implement this is by creating an abstracted service. This approach encapsulates the JS Interop logic, makes it reusable, testable, and cleanly separates your component logic from the implementation details.

Here is the definitive, step-by-step guide to implementing this correctly for a user's circuit state.

The Recommended Approach: A Scoped Service with JS Interop

This pattern ensures that:

The logic is centralized and not duplicated in every component.

The service's lifetime is tied to the user's circuit.

Your components remain clean and only depend on a C# interface, not on IJSRuntime.

Step 1: Create the JavaScript Interop File

First, create the JavaScript functions that will interact with the browser's sessionStorage.

In your wwwroot folder, create a new folder like js and add a file named sessionStorageInterop.js.

wwwroot/js/sessionStorageInterop.js

Generated javascript
// This function saves a value to the browser's sessionStorage.
// We use JSON.stringify to allow storing complex objects, not just strings.
window.saveToSessionStorage = (key, value) => {
    try {
        const jsonValue = JSON.stringify(value);
        sessionStorage.setItem(key, jsonValue);
    } catch (e) {
        console.error("Failed to save to session storage", e);
    }
};

// This function retrieves a value from sessionStorage.
// We use JSON.parse to convert the string back into its original form.
window.readFromSessionStorage = (key) => {
    try {
        const jsonValue = sessionStorage.getItem(key);
        if (jsonValue === null) {
            return null;
        }
        return JSON.parse(jsonValue);
    } catch (e) {
        console.error("Failed to read from session storage", e);
        return null;
    }
};

Step 2: Create the Service Abstraction (Interface and Implementation)

Create a C# service that will call these JavaScript functions. This is the heart of the solution.

ISessionStorageService.cs (The Interface)

Generated csharp
public interface ISessionStorageService
{
    Task<T?> GetItemAsync<T>(string key);
    Task SetItemAsync<T>(string key, T value);
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
C#
IGNORE_WHEN_COPYING_END

SessionStorageService.cs (The Implementation)

Generated csharp
using Microsoft.JSInterop;
using System.Text.Json;

public class SessionStorageService : ISessionStorageService
{
    private readonly IJSRuntime _jsRuntime;

    // Inject IJSRuntime to be able to call JavaScript functions.
    public SessionStorageService(IJSRuntime jsRuntime)
    {
        _jsRuntime = jsRuntime;
    }

    public async Task<T?> GetItemAsync<T>(string key)
    {
        // Calls the 'readFromSessionStorage' JavaScript function
        var jsonValue = await _jsRuntime.InvokeAsync<string?>("readFromSessionStorage", key);
        if (jsonValue is null)
        {
            return default;
        }
        return JsonSerializer.Deserialize<T>(jsonValue);
    }

    public async Task SetItemAsync<T>(string key, T value)
    {
        // Calls the 'saveToSessionStorage' JavaScript function
        await _jsRuntime.InvokeVoidAsync("saveToSessionStorage", key, value);
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
C#
IGNORE_WHEN_COPYING_END
Step 3: Register the Service and Include the Script

Now, register the service with the dependency injection container and link the JavaScript file.

In your Program.cs:

Generated csharp
// ... other services

// Register the service with a Scoped lifetime.
// This is crucial: it creates one instance per user circuit,
// which is exactly what we want for circuit state.
builder.Services.AddScoped<ISessionStorageService, SessionStorageService>();

var app = builder.Build();

// ... other middleware

// Ensure the static files middleware is present
app.UseStaticFiles();

// ... map razor components, etc.

app.Run();
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
C#
IGNORE_WHEN_COPYING_END

In your main layout file, typically App.razor, add a script tag for your JS interop file. This ensures it's available to the application.

Generated html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link rel="stylesheet" href="bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="MyBlazorApp.styles.css" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
    
    <!-- Add your custom script here -->
    <script src="js/sessionStorageInterop.js"></script>
</body>

</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END
Step 4: Use the Service in Your Interactive Component

Now you can inject and use the service in any component that has an interactive render mode.

Important: This will only work in interactive components because static SSR components cannot perform JS interop.

Here is an example component using Interactive Server mode.

Counter.razor

Generated csharp
@page "/counter"
@rendermode InteractiveServer
@inject ISessionStorageService SessionStorage

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
    private int currentCount;
    private const string CounterKey = "userCounterValue";

    // Use OnAfterRenderAsync to safely interact with JS Interop
    // after the component has rendered in the browser.
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only on the very first render, try to load the state.
        if (firstRender)
        {
            var storedCount = await SessionStorage.GetItemAsync<int?>(CounterKey);
            if (storedCount.HasValue)
            {
                currentCount = storedCount.Value;
                // We must call StateHasChanged here because the state is updated
                // asynchronously after the initial render.
                StateHasChanged();
            }
        }
    }

    private async Task IncrementCount()
    {
        currentCount++;
        // Persist the new value to sessionStorage
        await SessionStorage.SetItemAsync(CounterKey, currentCount);
    }
}
