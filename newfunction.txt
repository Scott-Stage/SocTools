Great—your setup (one service per API, each with multiple endpoint methods) is a perfect fit for **typed HttpClient** in Blazor Server. Give each service its **own HttpClient** with its own **BaseAddress** via `AddHttpClient<TService>()`. Then inject that `HttpClient` into the service’s constructor. No dispose needed; DI + factory manage lifetimes safely.

Below is a complete, copy-pasteable pattern.

# appsettings.json

```json
{
  "Apis": {
    "Api1": { "BaseUrl": "https://api1.example.com/" },
    "Api2": { "BaseUrl": "https://api2.example.com/" }
  }
}
```

# Program.cs (Blazor Server)

```csharp
var builder = WebApplication.CreateBuilder(args);
var cfg = builder.Configuration;

// Optional per-API handlers (auth, retry, etc.)
builder.Services.AddTransient<Api1AuthHandler>();
builder.Services.AddTransient<Api2AuthHandler>();

// Typed clients: one per service, each with its own BaseAddress + handlers
builder.Services.AddHttpClient<Api1Service>((sp, c) =>
{
    c.BaseAddress = new Uri(cfg["Apis:Api1:BaseUrl"]!);
    c.DefaultRequestHeaders.Accept.ParseAdd("application/json");
})
.AddHttpMessageHandler<Api1AuthHandler>(); // remove if not needed

builder.Services.AddHttpClient<Api2Service>((sp, c) =>
{
    c.BaseAddress = new Uri(cfg["Apis:Api2:BaseUrl"]!);
    c.DefaultRequestHeaders.Accept.ParseAdd("application/json");
})
.AddHttpMessageHandler<Api2AuthHandler>(); // remove if not needed

// Your services are scoped (recommended for Blazor Server)
builder.Services.AddScoped<Api1Service>();
builder.Services.AddScoped<Api2Service>();

var app = builder.Build();
app.Run();

// Example bearer handlers (optional)
public sealed class Api1AuthHandler : DelegatingHandler
{
    protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage r, CancellationToken ct)
    {
        // attach a token/header specific to API1 if needed
        // r.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
        return base.SendAsync(r, ct);
    }
}
public sealed class Api2AuthHandler : DelegatingHandler
{
    protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage r, CancellationToken ct)
    {
        // attach a token/header specific to API2 if needed
        return base.SendAsync(r, ct);
    }
}
```

# api1service.cs (multiple endpoint methods for API 1)

```csharp
using System.Net.Http.Json;
using System.Text.Json;

public sealed class Api1Service
{
    private readonly HttpClient _http;
    private static readonly JsonSerializerOptions JsonOpts = new() { PropertyNameCaseInsensitive = true };

    public Api1Service(HttpClient http) => _http = http;

    // GET https://api1.../v1/items
    public async Task<List<ItemDto>> GetItemsAsync(CancellationToken ct = default) =>
        await _http.GetFromJsonAsync<List<ItemDto>>("v1/items", JsonOpts, ct) ?? new();

    // GET https://api1.../v1/items/{id}
    public async Task<ItemDto?> GetItemAsync(string id, CancellationToken ct = default) =>
        await _http.GetFromJsonAsync<ItemDto>($"v1/items/{Uri.EscapeDataString(id)}", JsonOpts, ct);

    // POST https://api1.../v1/items
    public async Task<ItemDto> CreateItemAsync(CreateItemDto dto, CancellationToken ct = default)
    {
        using var resp = await _http.PostAsJsonAsync("v1/items", dto, JsonOpts, ct);
        resp.EnsureSuccessStatusCode();
        return (await resp.Content.ReadFromJsonAsync<ItemDto>(JsonOpts, ct))!;
    }

    // Streaming download safely (no ObjectDisposed issues)
    // GET https://api1.../v1/reports/{id}/download
    public async Task DownloadReportAsync(string id, Stream destination, CancellationToken ct = default)
    {
        using var resp = await _http.GetAsync($"v1/reports/{Uri.EscapeDataString(id)}/download",
                                              HttpCompletionOption.ResponseHeadersRead, ct);
        resp.EnsureSuccessStatusCode();
        await using var s = await resp.Content.ReadAsStreamAsync(ct);
        await s.CopyToAsync(destination, ct);
    }
}

// Example DTOs
public sealed class ItemDto { public string? Id { get; set; } public string? Name { get; set; } }
public sealed class CreateItemDto { public string? Name { get; set; } }
```

# api2service.cs (multiple endpoint methods for API 2)

```csharp
using System.Net.Http.Json;
using System.Text.Json;

public sealed class Api2Service
{
    private readonly HttpClient _http;
    private static readonly JsonSerializerOptions JsonOpts = new() { PropertyNameCaseInsensitive = true };

    public Api2Service(HttpClient http) => _http = http;

    public async Task<SearchResultDto> SearchAsync(string q, CancellationToken ct = default)
        => (await _http.GetFromJsonAsync<SearchResultDto>($"api/search?q={Uri.EscapeDataString(q)}", JsonOpts, ct))!;

    public async Task<bool> DeleteAsync(string id, CancellationToken ct = default)
    {
        using var resp = await _http.DeleteAsync($"api/resources/{Uri.EscapeDataString(id)}", ct);
        return resp.IsSuccessStatusCode;
    }
}

public sealed class SearchResultDto
{
    public List<SearchHitDto> Hits { get; set; } = new();
}
public sealed class SearchHitDto { public string? Id { get; set; } public string? Title { get; set; } }
```

## Why this avoids “disposed HttpClient”

* Each service gets a **typed** `HttpClient` from DI with the correct **BaseAddress**, and **you never dispose it**.
* Streaming methods fully consume the content **before** leaving the method, so the `HttpResponseMessage` can be disposed safely.
* Services are **Scoped**, which is the right lifetime for Blazor Server components.

## Variations

* If you prefer **named clients**: register `AddHttpClient("Api1", …)`, `AddHttpClient("Api2", …)` and inject `IHttpClientFactory` into each service, calling `_factory.CreateClient("Api1")` or `"Api2"` inside the methods.
* Per-API auth/retry: attach different `DelegatingHandler`s or Polly policies to each `AddHttpClient`.

If you paste your current `Program.cs` and one of your `apiXservice.cs` files, I can convert them directly to this pattern with your actual endpoints/DTOs.
