Nice—since you’re doing the auth flow yourself, the easiest way to “know it worked” is to (a) check that you **have a live access token** in session and (b) optionally **decode it** to see audience/scopes/expiry, then (c) make a tiny **/me** call as a runtime proof.

Below are drop-in additions to your `MicrosoftGraphApiService.cs` plus a tiny Razor snippet you can use to verify.

---

## 1) Add quick status helpers to `MicrosoftGraphApiService.cs`

```csharp
using System.IdentityModel.Tokens.Jwt; // add package: System.IdentityModel.Tokens.Jwt
using System.Linq;

// Snapshot DTO for easy display/diagnostics
public sealed class TokenSnapshot
{
    public bool            IsConnected   { get; init; }
    public DateTimeOffset? ExpiresUtc    { get; init; }
    public string?         Audience      { get; init; }
    public string?         TenantId      { get; init; }
    public string?         Username      { get; init; }
    public string[]        Scopes        { get; init; } = Array.Empty<string>();
    public string[]        Roles         { get; init; } = Array.Empty<string>();
    public string?         Raw           { get; init; } // show only in dev
}

/// <summary>Returns true if a valid (or refreshable) access token is present.</summary>
public async Task<bool> IsConnectedAsync(CancellationToken ct = default)
{
    try { _ = await GetValidAccessTokenAsync(ct); return true; }
    catch { return false; }
}

/// <summary>Decode the access token (without signature validation) for diagnostics.</summary>
public TokenSnapshot? GetAccessTokenSnapshot()
{
    var token = _http.HttpContext!.Session.GetString(SessAccessToken);
    if (string.IsNullOrEmpty(token)) return null;

    var handler = new JwtSecurityTokenHandler();
    var jwt = handler.ReadJwtToken(token);

    var scopes = jwt.Claims.Where(c => c.Type == "scp")
                           .SelectMany(c => c.Value.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                           .ToArray();
    var roles  = jwt.Claims.Where(c => c.Type == "roles").Select(c => c.Value).ToArray();

    return new TokenSnapshot
    {
        IsConnected = true,
        ExpiresUtc  = DateTime.SpecifyKind(jwt.ValidTo, DateTimeKind.Utc),
        Audience    = jwt.Audiences.FirstOrDefault(),
        TenantId    = jwt.Claims.FirstOrDefault(c => c.Type == "tid")?.Value,
        Username    = jwt.Claims.FirstOrDefault(c => c.Type == "preferred_username" || c.Type == "upn")?.Value,
        Scopes      = scopes,
        Roles       = roles,
#if DEBUG
        Raw         = token
#endif
    };
}
```

> These do **not** validate the JWT signature—that’s fine for a quick “did we get a token?” check. For production validation, use `TokenValidationParameters` with issuer signing keys, but you usually don’t need that for this purpose.

---

## 2) Quick Razor page to verify everything

```razor
@page "/graph/status"
@inject MicrosoftGraphApiService GraphSvc

<h3>Graph Auth Status</h3>

@if (_snap is null)
{
    <p>Not connected.</p>
    <p><a href="/graph/start">Connect now</a></p>
}
else
{
    <ul>
        <li><b>User</b>: @_snap.Username</li>
        <li><b>Audience</b>: @_snap.Audience</li>
        <li><b>Tenant</b>: @_snap.TenantId</li>
        <li><b>Expires (UTC)</b>: @_snap.ExpiresUtc</li>
        <li><b>Scopes</b>: @string.Join(", ", _snap.Scopes)</li>
        <li><b>Roles</b>: @string.Join(", ", _snap.Roles)</li>
    </ul>
    <button class="btn btn-secondary" @onclick="CallMe">Call /me</button>
    <pre>@_result</pre>
#if DEBUG
    <details><summary>Raw access token (dev)</summary><code>@_snap.Raw</code></details>
#endif
}

@code {
    private TokenSnapshot? _snap;
    private string _result = "";

    protected override async Task OnInitializedAsync()
    {
        _snap = await GraphSvc.IsConnectedAsync()
            ? GraphSvc.GetAccessTokenSnapshot()
            : null;
    }

    private async Task CallMe()
    {
        try {
            var me = await GraphSvc.GetMeAsync();
            _result = me?.ToString() ?? "No /me payload";
        } catch (Exception ex) {
            _result = ex.Message;
        }
    }
}
```

**What to look for:**

* `Audience` should be `https://graph.microsoft.com`.
* `Scopes` should include `User.Read` and (when requested) `eDiscovery.Read.All`.
* `Expires (UTC)` should be in the future.
* Clicking **Call /me** should return a JSON object with your account’s properties.

---

## 3) If it still feels ambiguous, add a simple health endpoint

(Only if you want a non-UI check.)

```csharp
// Program.cs (optional)
app.MapGet("/graph/health", async (MicrosoftGraphApiService svc) =>
{
    var ok = await svc.IsConnectedAsync();
    var snap = ok ? svc.GetAccessTokenSnapshot() : null;
    return Results.Json(new {
        connected = ok,
        audience = snap?.Audience,
        expiresUtc = snap?.ExpiresUtc,
        scopes = snap?.Scopes
    });
});
```

---

## 4) Common reasons you’d “complete auth” but have no token

* You exchanged the `code` successfully but didn’t **persist** `access_token` in session (double-check the session set and that `UseSession()` is before routing).
* The token request returned **success for ID token only** (make sure you request **API scopes**—e.g., `User.Read eDiscovery.Read.All`—not just `openid profile`).
* You’re checking the token later but **reading a different session** (host/port mismatch or SameSite cookie not sent back). The `/graph/status` page will make this obvious.

---

With these helpers, you’ll know in one glance:

* Are we connected?
* What’s in the token (audience, scopes, expiry)?
* Does a real Graph call work?
