public void ExtractUrls()
{
    // Always produce a fresh list
    var results = new List<string>();

    if (string.IsNullOrWhiteSpace(input))
    {
        links = results;
        return;
    }

    var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    // Match:
    //   https://gccx.safelinks.outlook.com/...
    //   https://gcc01.safelinks.protection.outlook.com/...
    //   https://gccNN.safelinks.outlook.com/...
    var safeLinkRegex = new Regex(
        @"https?://(?:gccx|gcc\d+)\.safelinks(?:\.protection)?\.outlook\.com/[^\s'""<>)]+",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    foreach (Match m in safeLinkRegex.Matches(input))
    {
        // Full Safe Link (trim common trailing punctuation attached by surrounding text)
        var safeLink = m.Value.TrimEnd('.', ',', ';', ')', ']', '}', '>', '"', '\'');

        if (seen.Add(safeLink))
            results.Add(safeLink);

        // Try to pull the original target from ?url=...
        if (Uri.TryCreate(safeLink, UriKind.Absolute, out var uri))
        {
            var target = GetQueryParam(uri.Query, "url");
            if (!string.IsNullOrEmpty(target))
            {
                // Many Safe Links double-encode; decode twice and HTML-decode
                var decoded = WebUtility.UrlDecode(WebUtility.UrlDecode(target));
                decoded = WebUtility.HtmlDecode(decoded)?.Trim();

                if (!string.IsNullOrEmpty(decoded))
                {
                    // Strip angle brackets if present (sometimes included)
                    decoded = decoded.Trim('<', '>');

                    // Only keep well-formed absolute URLs
                    if (Uri.IsWellFormedUriString(decoded, UriKind.Absolute))
                    {
                        if (seen.Add(decoded))
                            results.Add(decoded);
                    }
                }
            }
        }
    }

    // Publish the new list
    links = results;
}

// Minimal query parser that avoids extra dependencies.
// Accepts a full query string (with or without leading '?').
private static string? GetQueryParam(string query, string key)
{
    if (string.IsNullOrEmpty(query)) return null;

    ReadOnlySpan<char> span = query.AsSpan();
    if (!span.IsEmpty && span[0] == '?')
        span = span[1..];

    while (!span.IsEmpty)
    {
        int amp = span.IndexOf('&');
        var pair = amp >= 0 ? span[..amp] : span;
        span = amp >= 0 ? span[(amp + 1)..] : ReadOnlySpan<char>.Empty;

        int eq = pair.IndexOf('=');
        var k = (eq >= 0 ? pair[..eq] : pair).ToString();
        if (k.Equals(key, StringComparison.OrdinalIgnoreCase))
            return eq >= 0 ? pair[(eq + 1)..].ToString() : string.Empty;
    }

    return null;
}