// Services/ComponentTaskRunner.cs
using System.Threading;

public class ComponentTaskRunner : IDisposable
{
    private CancellationTokenSource? _cts;
    private SemaphoreSlim? _throttleLock;
    private bool _isRunning = false;

    // The Start method is now guarded by the _isRunning flag.
    public void Start(
        TimeSpan interval,
        Action onStateHasChanged,
        int maxConcurrency,
        params Func<Task>[] workFunctions)
    {
        // Prevent starting if it's already running.
        if (_isRunning) return;
        
        if (workFunctions == null || workFunctions.Length == 0) return;

        _isRunning = true;
        int concurrency = Math.Max(1, maxConcurrency);
        _throttleLock = new SemaphoreSlim(concurrency, concurrency);
        _cts = new CancellationTokenSource();
        
        // Start the background task.
        _ = DoContinuousWorkAsync(interval, onStateHasChanged, workFunctions, _cts.Token);
    }

    // The NEW public Stop method.
    public void Stop()
    {
        if (!_isRunning) return;

        // Signal the cancellation token to gracefully stop the loop.
        _cts?.Cancel();
        
        _isRunning = false;
    }

    private async Task DoContinuousWorkAsync(TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, CancellationToken token)
    {
        // ... The internal loop logic remains exactly the same ...
        while (!token.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(interval, token);
            }
            catch (OperationCanceledException) { break; }

            var tasksInThisRun = workFunctions.Select(work => ExecuteThrottledWorkAsync(work, token));
            await Task.WhenAll(tasksInThisRun);

            if (!token.IsCancellationRequested)
            {
                onStateHasChanged?.Invoke();
            }
        }
    }

    private async Task ExecuteThrottledWorkAsync(Func<Task> work, CancellationToken token)
    {
        await _throttleLock!.WaitAsync(token);
        try
        {
            await Task.Run(work, token);
        }
        finally
        {
            _throttleLock.Release();
        }
    }

    // The Dispose method now acts as the final, ultimate cleanup.
    public void Dispose()
    {
        // Ensure the loop is stopped before we dispose the resources.
        if (_isRunning)
        {
            Stop();
        }
        _cts?.Dispose();
        _throttleLock?.Dispose();
    }
}