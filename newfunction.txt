export function scrollToBottom(elementId) {
  const element = document.getElementById(elementId);
  if (element) {
    element.scrollTop = element.scrollHeight;
  }
}



@page "/file-reader"
@using System.IO
@using System.Text
@using System.Threading
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable @* Use IAsyncDisposable for async cleanup *@

<h1>Real-time File Content Viewer</h1>

<p>
    <label for="filePath">File Path:</label>
    <input id="filePath" @bind="filePath" style="width: 500px;" />
</p>

<p>
    <label for="refreshInterval">Refresh Interval (ms):</label>
    <input id="refreshInterval" type="number" @bind="refreshInterval" />
</p>

<button class="btn btn-primary" @onclick="StartReading">Start Reading</button>
<button class="btn btn-secondary" @onclick="StopReading">Stop Reading</button>

<hr />

<h3>File Content:</h3>

<div id="file-content-container" style="height: 800px; overflow-y: scroll; border: 1px solid #ccc; background-color: #f5f5f5;">
    <pre>@fileContent</pre>
</div>

@code {
    private string? filePath = "C:\\path\\to\\your\\file.txt"; // TODO: Change this to the path of the file you want to monitor.
    private int refreshInterval = 1000;
    private string? fileContent;
    private Timer? timer;
    private bool shouldScrollToBottom = false;

    // This will hold a reference to our isolated JavaScript module
    private IJSObjectReference? module;

    private void StartReading()
    {
        timer?.Dispose();
        timer = new Timer(async _ => await ReadFile(), null, 0, refreshInterval);
    }

    private async Task ReadFile()
    {
        // ... (ReadFile logic is the same as before)
        try
        {
            if (File.Exists(filePath))
            {
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                {
                    string newContent = await streamReader.ReadToEndAsync();
                    if (newContent != fileContent)
                    {
                        fileContent = newContent;
                        shouldScrollToBottom = true;
                    }
                }
            }
            else
            {
                fileContent = "File not found.";
            }
        }
        catch (Exception ex)
        {
            fileContent = $"Error reading file: {ex.Message}";
        }
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // On the first render, load the JavaScript module.
        if (firstRender)
        {
            // The path './' refers to the location of the current component.
            // Blazor knows to look for FileContentReader.razor.js
            module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./FileContentReader.razor.js");
        }

        // If a scroll is needed and the module is loaded, perform the scroll.
        if (shouldScrollToBottom && module is not null)
        {
            await module.InvokeVoidAsync("scrollToBottom", "file-content-container");
            shouldScrollToBottom = false;
        }
    }

    private void StopReading()
    {
        timer?.Dispose();
    }

    // Implement IAsyncDisposable to clean up the JS module reference
    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            await module.DisposeAsync();
        }
        timer?.Dispose();
    }
}```

### Why This Approach is Better

1.  **Encapsulation:** All the logic (HTML, C#, and JS) for your component is located in one place, making it easy to manage, reuse, and share.
2.  **No Global Scope Pollution:** The `scrollToBottom` function is part of a module, not attached to the global `window` object. This prevents conflicts with other scripts in your application.
3.  **On-Demand Loading:** The JavaScript file is only downloaded to the client's browser when the component that needs it is actually rendered on a page.
4.  **Robustness:** This is the officially supported and documented method from Microsoft for JS Interop, making it the most reliable and future-proof option.