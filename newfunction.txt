import os
import re
import string
import math # For infinity
import textwrap # Import for word wrapping

# --- Configuration ---
DEBUG = False
JACCARD_PROMOTION_THRESHOLD = 0.5

# --- Column Widths for Output Table ---
WIDTH_MY_SW = 40
WIDTH_MATCHED_COL = 40 # Used for Matched DB, Potential Matches, Nearest Candidate
WIDTH_REASON = 35

def read_software_list(filepath):
    """Reads a software list from a file, one item per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

def normalize_name(name):
    """Normalizes software name."""
    if not name: return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator)
    name = name.lower().strip()
    name = re.sub(r'\s+', ' ', name)
    tokens = name.split()
    unique_sorted_tokens = sorted(list(set(filter(None, tokens))))
    if not unique_sorted_tokens: return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    """ Calculates Jaccard distance: len(symm_diff) / len(union) """
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0
    return len(sym_diff) / len(union)

def compare_lists(my_software_list, db_software_list):
    """
    Compares lists and gathers detailed results for table output.
    Returns a list of dictionaries, one for each item in my_software_list.
    """
    if my_software_list is None or db_software_list is None: return None

    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item)
    if DEBUG: print(f"Normalized DB forms: {list(db_token_sets.keys())}")

    comparison_results = []
    processed_my_software_originals = set()

    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found',
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': None
        }
        if my_sw_orig in processed_my_software_originals: continue
        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}): '{my_sw_orig}' ---")
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
            result_entry['reason'] = "Input normalizes to empty"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
             result_entry['reason'] = "Input has no valid tokens"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        found_direct_full_match = False
        potential_partial_details = []
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1;
            if not db_tokens: continue;
            if DEBUG: print(f"  Checking against DB entry {db_check_counter}: '{db_norm}' | Tokens: {db_tokens}")
            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)
            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist; best_overall_candidate_norm = db_norm
            if DEBUG: print(f"    Symm Diff: {symmetric_difference} (Size: {sym_diff_len}) | Jaccard Dist: {jaccard_dist:.4f}")

            if sym_diff_len <= 1:
                if DEBUG: print(f"    --> Direct Full Match found (Symm Diff <= 1).")
                result_entry['status'] = 'Full Match'; result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"; result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True; break

            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens"
            if partial_reason:
                 potential_partial_details.append({'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason})
                 if DEBUG: print(f"    --> Recording potential Partial Match details (Reason: {partial_reason}, Jaccard: {jaccard_dist:.4f}, DB Norm: {db_norm}).")
            elif DEBUG: print(f"    --> No Full or Potential Partial match criteria met.")

        if not found_direct_full_match:
            if potential_partial_details:
                best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
                min_partial_jaccard = best_potential['jaccard']
                best_partial_reason = best_potential['reason']
                best_partial_db_norm = best_potential['db_norm']
                all_partial_db_origs = set()
                for detail in potential_partial_details: all_partial_db_origs.update(db_normalized_map[detail['db_norm']])
                result_entry['all_partial_db_matches'] = sorted(list(all_partial_db_origs))
                if DEBUG: print(f"  Potential partial matches found. Min Jaccard Distance: {min_partial_jaccard:.4f} (Reason: {best_partial_reason})")

                if min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD:
                    result_entry['status'] = 'Full Match'; result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"; result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Promoted)")
                else:
                    result_entry['status'] = 'Partial Match'; result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"; result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Partial Match")
            else:
                result_entry['status'] = 'Not Found'
                if best_overall_candidate_norm:
                     result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                     result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                     result_entry['reason'] = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                else: result_entry['reason'] = "No DB entries to compare"
                if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Not Found")
        elif DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Direct)")

        comparison_results.append(result_entry)
        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return comparison_results


def write_results_table(output_file, comparison_results):
    """Writes the categorized results to a file in table format with word wrap."""
    if comparison_results is None:
        print("Skipping writing results due to previous errors.")
        return

    full_matches = sorted([r for r in comparison_results if r['status'] == 'Full Match'], key=lambda x: x['my_sw_orig'])
    partial_matches = sorted([r for r in comparison_results if r['status'] == 'Partial Match'], key=lambda x: x['my_sw_orig'])
    not_found = sorted([r for r in comparison_results if r['status'] == 'Not Found'], key=lambda x: x['my_sw_orig'])

    # Helper to get wrapped lines or a default if text is None
    def get_wrapped_lines(text, width, default="N/A"):
        if text is None:
            text = default
        # Initial indent and subsequent indent are empty for table cells
        return textwrap.wrap(text, width=width, initial_indent="", subsequent_indent="", drop_whitespace=True) or [default]


    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("Software Comparison Results\n")
            f.write("=" * (WIDTH_MY_SW + WIDTH_MATCHED_COL + WIDTH_REASON + 6) + "\n\n")

            # --- Full Matches Table ---
            f.write("=== Full Matches ===\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Matched DB Entry':<{WIDTH_MATCHED_COL}} | {'Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if full_matches:
                for item in full_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matched_db_lines = get_wrapped_lines(item['matched_db_orig'], WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matched_db_lines), len(reason_lines))

                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matched_part = matched_db_lines[i] if i < len(matched_db_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matched_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- Partial Matches Table ---
            f.write("=== Partial Matches ===\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Potential DB Matches':<{WIDTH_MATCHED_COL}} | {'Best Match Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if partial_matches:
                for item in partial_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matches_str = (', '.join(item['all_partial_db_matches']) if item['all_partial_db_matches'] else "N/A")
                    matches_lines = get_wrapped_lines(matches_str, WIDTH_MATCHED_COL) # Wrap the combined string
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matches_lines), len(reason_lines))

                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matches_part = matches_lines[i] if i < len(matches_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matches_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- No Matches Table ---
            f.write("=== No Matches Found ===\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Nearest DB Candidate':<{WIDTH_MATCHED_COL}} | {'Reason (Nearest Candidate)':<{WIDTH_REASON}}" # Matched col width used here too
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if not_found:
                for item in not_found:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    nearest_lines = get_wrapped_lines(item['nearest_candidate_orig'], WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(nearest_lines), len(reason_lines))

                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        nearest_part = nearest_lines[i] if i < len(nearest_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {nearest_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")

    except Exception as e:
        print(f"Error writing results table to file {output_file}: {e}")


# --- Main Execution ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results_table.txt" # New output file name

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print(f"Comparing lists (Jaccard promotion threshold: {JACCARD_PROMOTION_THRESHOLD})...")
        detailed_results = compare_lists(my_list, db_list)
        write_results_table(output_result_file, detailed_results)
    else:
        print("Comparison cancelled due to errors reading input files.")