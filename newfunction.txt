public void ExtractUrls()
{
    var results = new List<string>();
    var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    if (string.IsNullOrWhiteSpace(input))
    {
        links = results;
        return;
    }

    // 1) Common HTML attributes (href, src, data-src, poster, action)
    var attrRegex = new Regex(
        @"\b(?:href|src|data-src|poster|action)\s*=\s*(?:""(?<u>[^""]+)""|'(?<u>[^']+)'|(?<u>[^\s>]+))",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    // 2) CSS url(...)
    var cssUrlRegex = new Regex(
        @"url\(\s*(?:['""])?(?<u>[^'""\)]+)(?:['""])?\s*\)",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    // 3) Naked http(s) links in text
    var nakedUrlRegex = new Regex(
        @"https?://[^\s'""<>)]+",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    void Consider(string raw)
    {
        if (string.IsNullOrWhiteSpace(raw)) return;

        // Clean common punctuation and HTML-decode
        var candidate = WebUtility.HtmlDecode(raw.Trim())
            .Trim('<', '>', ' ')
            .TrimEnd('.', ',', ';', ')', ']', '}', '>', '"', '\'');

        if (string.IsNullOrWhiteSpace(candidate)) return;

        // Try to unwrap Outlook Safe Links; if unwrapped, use the target
        var unwrapped = TryUnwrapOutlookSafeLink(candidate);

        // We include:
        //  - Absolute http/https URLs
        //  - Relative paths (from attributes) as-is
        if (Uri.IsWellFormedUriString(unwrapped, UriKind.Absolute))
        {
            if (seen.Add(unwrapped)) results.Add(unwrapped);
        }
        else if (unwrapped.StartsWith("/") || unwrapped.StartsWith("./") || unwrapped.StartsWith("../"))
        {
            // keep relative path values from attributes/CSS
            if (seen.Add(unwrapped)) results.Add(unwrapped);
        }
        // Otherwise ignore things like javascript:, mailto:, data:, etc.
    }

    foreach (Match m in attrRegex.Matches(input))
        Consider(m.Groups["u"].Value);

    foreach (Match m in cssUrlRegex.Matches(input))
        Consider(m.Groups["u"].Value);

    foreach (Match m in nakedUrlRegex.Matches(input))
        Consider(m.Value);

    links = results;
}

/// <summary>
/// If the URL is an Outlook Safe Link (any region/tenant, incl. GCC/GCC High),
/// extract and return the decoded target (from url=/target=/destination=/targeturl=).
/// If not a safelink or no target found, returns the original url unchanged.
/// </summary>
private static string TryUnwrapOutlookSafeLink(string url)
{
    if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))
        return url;

    var host = uri.Host;
    if (!(host.EndsWith("safelinks.outlook.com", StringComparison.OrdinalIgnoreCase) ||
          host.EndsWith("safelinks.protection.outlook.com", StringComparison.OrdinalIgnoreCase)))
        return url;

    var target =
        TryGetQueryParam(uri.Query, "url") ??
        TryGetQueryParam(uri.Query, "target") ??
        TryGetQueryParam(uri.Query, "destination") ??
        TryGetQueryParam(uri.Query, "targeturl");

    if (string.IsNullOrEmpty(target))
        return url;

    // Safe Links often double-encode and may HTML-encode internally
    var decoded = WebUtility.UrlDecode(WebUtility.UrlDecode(target));
    decoded = WebUtility.HtmlDecode(decoded)?.Trim('<', '>', ' ', '\t', '\r', '\n');

    return string.IsNullOrWhiteSpace(decoded) ? url : decoded!;
}

/// <summary>
/// Minimal query-string param reader (case-insensitive).
/// Accepts query with or without leading '?'
/// </summary>
private static string? TryGetQueryParam(string query, string key)
{
    if (string.IsNullOrEmpty(query)) return null;

    ReadOnlySpan<char> s = query.AsSpan();
    if (!s.IsEmpty && s[0] == '?') s = s[1..];

    while (!s.IsEmpty)
    {
        int amp = s.IndexOf('&');
        var pair = amp >= 0 ? s[..amp] : s;
        s = amp >= 0 ? s[(amp + 1)..] : ReadOnlySpan<char>.Empty;

        int eq = pair.IndexOf('=');
        var k = (eq >= 0 ? pair[..eq] : pair).ToString();
        if (k.Equals(key, StringComparison.OrdinalIgnoreCase))
            return eq >= 0 ? pair[(eq + 1)..].ToString() : string.Empty;
    }
    return null;
}