@page "/acl-parser"

<PageTitle>ACL Parser</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="py-6 acl-parser-page">
    <MudStack Spacing="3">
        <MudPaper Elevation="2" Class="p-4">
            <MudStack Spacing="2">
                <MudText Typo="Typo.h5" Class="font-weight-bold">Cisco ACL Parser</MudText>
                <MudText Typo="Typo.body2" Class="text-secondary">
                    Drop a Cisco ACL config file to extract source, destination, protocol, and rule metadata.
                </MudText>
                <div class="acl-drop-zone">
                    <InputFile OnChange="HandleFileSelected" class="acl-drop-input" accept=".txt,.cfg,.conf,.acl" />
                    <div class="acl-drop-content">
                        <MudText Typo="Typo.subtitle1" Class="font-weight-bold">Drag &amp; drop a config file</MudText>
                        <MudText Typo="Typo.caption" Class="text-secondary">or click to browse</MudText>
                        @if (!string.IsNullOrWhiteSpace(UploadedFileName))
                        {
                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined">
                                @UploadedFileName
                            </MudChip>
                        }
                    </div>
                </div>
                @if (IsLoading)
                {
                    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                }
                else if (Entries.Count > 0)
                {
                    <MudStack Direction="Row" Spacing="2" AlignItems="AlignItems.Center">
                        <MudChip T="string" Color="Color.Info" Variant="Variant.Filled">Entries: @Entries.Count</MudChip>
                        <MudChip T="string" Color="Color.Success" Variant="Variant.Filled">Permits: @Entries.Count(e => e.Action == "permit")</MudChip>
                        <MudChip T="string" Color="Color.Error" Variant="Variant.Filled">Denies: @Entries.Count(e => e.Action == "deny")</MudChip>
                        <MudChip T="string" Color="Color.Default" Variant="Variant.Filled">Remarks: @Entries.Count(e => e.Action == "remark")</MudChip>
                        @if (UploadedAt is not null)
                        {
                            <MudText Typo="Typo.caption" Class="text-secondary">
                                Parsed @UploadedAt.Value.ToString("g")
                            </MudText>
                        }
                    </MudStack>
                }
                @if (ParseWarnings.Count > 0)
                {
                    <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">
                        @foreach (var warning in ParseWarnings)
                        {
                            <div>@warning</div>
                        }
                    </MudAlert>
                }
            </MudStack>
        </MudPaper>

        <MudPaper Elevation="2" Class="p-4">
            <MudTable Items="Entries" Dense="true" Hover="true" Striped="true" RowClassFunc="GetRowClass">
                <HeaderContent>
                    <MudTh>#</MudTh>
                    <MudTh>ACL</MudTh>
                    <MudTh>Action</MudTh>
                    <MudTh>Protocol</MudTh>
                    <MudTh>Source</MudTh>
                    <MudTh>Src Port</MudTh>
                    <MudTh>Destination</MudTh>
                    <MudTh>Dst Port</MudTh>
                    <MudTh>Comment</MudTh>
                    <MudTh>Options</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="#">@context.LineNumber</MudTd>
                    <MudTd DataLabel="ACL">@context.AclName</MudTd>
                    <MudTd DataLabel="Action">
                        <MudChip T="string" Color="@GetActionColor(context.Action)" Variant="Variant.Filled" Size="Size.Small">
                            @context.Action
                        </MudChip>
                    </MudTd>
                    <MudTd DataLabel="Protocol">@context.Protocol</MudTd>
                    <MudTd DataLabel="Source">@context.Source</MudTd>
                    <MudTd DataLabel="Src Port">@context.SourcePort</MudTd>
                    <MudTd DataLabel="Destination">@context.Destination</MudTd>
                    <MudTd DataLabel="Dst Port">@context.DestinationPort</MudTd>
                    <MudTd DataLabel="Comment">@context.Comment</MudTd>
                    <MudTd DataLabel="Options">@context.Options</MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    <MudText Typo="Typo.body2" Class="text-secondary">Upload a config to see parsed ACL rules.</MudText>
                </NoRecordsContent>
            </MudTable>
        </MudPaper>
    </MudStack>
</MudContainer>

<style>
    .acl-drop-zone {
        position: relative;
        border: 2px dashed rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 24px;
        min-height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, rgba(233, 243, 255, 0.7), rgba(255, 250, 230, 0.7));
    }

    .acl-drop-input {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
    }

    .acl-drop-content {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: center;
    }

    .acl-row-deny {
        background-color: rgba(244, 67, 54, 0.08);
    }

    .acl-row-remark {
        background-color: rgba(158, 158, 158, 0.08);
    }
</style>

@code {
    private readonly List<AclEntry> Entries = new();
    private readonly List<string> ParseWarnings = new();
    private string? UploadedFileName;
    private DateTime? UploadedAt;
    private bool IsLoading;

    private async Task HandleFileSelected(InputFileChangeEventArgs args)
    {
        var file = args.File;
        if (file is null)
        {
            return;
        }

        IsLoading = true;
        ParseWarnings.Clear();
        Entries.Clear();

        try
        {
            await using var stream = file.OpenReadStream(maxAllowedSize: 10_000_000);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();

            UploadedFileName = file.Name;
            UploadedAt = DateTime.Now;
            Entries.AddRange(ParseAcl(content));
        }
        catch (Exception ex)
        {
            ParseWarnings.Add($"Unable to parse file: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
        }
    }

    private IEnumerable<AclEntry> ParseAcl(string content)
    {
        var results = new List<AclEntry>();
        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentAclName = null;
        var inNamedAcl = false;

        for (var i = 0; i < lines.Length; i++)
        {
            var rawLine = lines[i];
            var lineNumber = i + 1;
            var trimmed = rawLine.Trim();

            if (string.IsNullOrWhiteSpace(trimmed))
            {
                continue;
            }

            if (trimmed.StartsWith("!", StringComparison.Ordinal) || trimmed.StartsWith("#", StringComparison.Ordinal))
            {
                continue;
            }

            var tokens = Tokenize(trimmed);
            if (tokens.Length == 0)
            {
                continue;
            }

            if (tokens.Length >= 3 &&
                tokens[0].Equals("ip", StringComparison.OrdinalIgnoreCase) &&
                tokens[1].Equals("access-list", StringComparison.OrdinalIgnoreCase))
            {
                if (tokens.Length >= 4)
                {
                    currentAclName = tokens[3];
                    inNamedAcl = true;
                }

                continue;
            }

            if (tokens[0].Equals("exit", StringComparison.OrdinalIgnoreCase) ||
                tokens[0].Equals("end", StringComparison.OrdinalIgnoreCase))
            {
                currentAclName = null;
                inNamedAcl = false;
                continue;
            }

            var entry = TryParseAclEntry(tokens, lineNumber, trimmed, currentAclName, inNamedAcl);
            if (entry is null)
            {
                if (LooksLikeAclLine(tokens))
                {
                    ParseWarnings.Add($"Line {lineNumber}: Unrecognized ACL syntax.");
                }
                continue;
            }

            results.Add(entry);
        }

        return results;
    }

    private static string[] Tokenize(string line)
    {
        return line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    }

    private static bool LooksLikeAclLine(string[] tokens)
    {
        if (tokens.Length == 0)
        {
            return false;
        }

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        var action = tokens[0];
        return IsActionToken(action) || action.Equals("remark", StringComparison.OrdinalIgnoreCase);
    }

    private static AclEntry? TryParseAclEntry(string[] tokens, int lineNumber, string raw, string? currentAclName, bool inNamedAcl)
    {
        var index = 0;
        var aclName = currentAclName;

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            if (tokens.Length < 3)
            {
                return null;
            }

            aclName = tokens[1];
            index = 2;
        }
        else if (!IsActionToken(tokens[0]) && !tokens[0].Equals("remark", StringComparison.OrdinalIgnoreCase))
        {
            if (!inNamedAcl)
            {
                return null;
            }

            index = 0;
        }

        if (index >= tokens.Length)
        {
            return null;
        }

        var action = tokens[index].ToLowerInvariant();
        if (action == "remark")
        {
            var comment = string.Join(' ', tokens.Skip(index + 1));
            return new AclEntry(lineNumber, raw, aclName ?? string.Empty, action, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, comment);
        }

        if (!IsActionToken(action))
        {
            return null;
        }

        index++;
        var protocol = index < tokens.Length ? tokens[index].ToLowerInvariant() : "ip";
        index++;

        var (source, afterSource) = ParseAddress(tokens, index);
        index = afterSource;

        var (sourcePort, afterSourcePort) = ParsePort(tokens, index);
        if (afterSourcePort != index)
        {
            index = afterSourcePort;
        }

        var (destination, afterDestination) = ParseAddress(tokens, index);
        index = afterDestination;

        var (destinationPort, afterDestinationPort) = ParsePort(tokens, index);
        if (afterDestinationPort != index)
        {
            index = afterDestinationPort;
        }

        var options = index < tokens.Length ? string.Join(' ', tokens.Skip(index)) : string.Empty;

        return new AclEntry(lineNumber, raw, aclName ?? string.Empty, action, protocol, source, sourcePort, destination, destinationPort, options, string.Empty);
    }

    private static (string Value, int NextIndex) ParseAddress(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start];
        if (token.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            return ("any", start + 1);
        }

        if (token.Equals("host", StringComparison.OrdinalIgnoreCase) && start + 1 < tokens.Length)
        {
            return ($"host {tokens[start + 1]}", start + 2);
        }

        if ((token.Equals("object", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("object-group", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("interface", StringComparison.OrdinalIgnoreCase)) &&
            start + 1 < tokens.Length)
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (LooksLikeIp(token) && start + 1 < tokens.Length && LooksLikeIp(tokens[start + 1]))
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (token.Contains('/', StringComparison.Ordinal))
        {
            return (token, start + 1);
        }

        return (token, start + 1);
    }

    private static (string Value, int NextIndex) ParsePort(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start].ToLowerInvariant();
        if (token is "eq" or "gt" or "lt" or "neq")
        {
            return start + 1 < tokens.Length
                ? ($"{token} {tokens[start + 1]}", start + 2)
                : (token, start + 1);
        }

        if (token == "range")
        {
            return start + 2 < tokens.Length
                ? ($"{token} {tokens[start + 1]} {tokens[start + 2]}", start + 3)
                : (token, start + 1);
        }

        return (string.Empty, start);
    }

    private static bool IsActionToken(string token)
    {
        return token.Equals("permit", StringComparison.OrdinalIgnoreCase) ||
               token.Equals("deny", StringComparison.OrdinalIgnoreCase);
    }

    private static bool LooksLikeIp(string token)
    {
        return System.Net.IPAddress.TryParse(token, out _);
    }

    private static Color GetActionColor(string action)
    {
        return action switch
        {
            "permit" => Color.Success,
            "deny" => Color.Error,
            "remark" => Color.Default,
            _ => Color.Info
        };
    }

    private static string GetRowClass(AclEntry entry, int index)
    {
        return entry.Action switch
        {
            "deny" => "acl-row-deny",
            "remark" => "acl-row-remark",
            _ => string.Empty
        };
    }

    private sealed record AclEntry(
        int LineNumber,
        string Raw,
        string AclName,
        string Action,
        string Protocol,
        string Source,
        string SourcePort,
        string Destination,
        string DestinationPort,
        string Options,
        string Comment);
}
