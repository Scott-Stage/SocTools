@page "/ACLParser/ACLParser"
@using System.Text.RegularExpressions
@using System.ComponentModel.DataAnnotations
@using System.Globalization
@using System.Security.Policy
@using System.Text
@using System.Net
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime _jsRuntime



@inherits ComponentBase;

<PageTitle>ACL Parser</PageTitle>

@code{
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {

            jsModule = await _jsRuntime.InvokeAsync<IJSObjectReference>("import",
                "./Components/Pages/ACL Parser/ACLParser.razor.js");
        }

        if (jsModule is not null && _pendingSplineLayout)
        {
            _pendingSplineLayout = false;
            await jsModule.InvokeVoidAsync("renderCrossZoneSplines", DetailScrollRef);
        }
    }

    private async Task HandleFolderSelected(InputFileChangeEventArgs args)
    {
        IsLoading = true;
        ParseWarnings.Clear();
        Entries.Clear();
        DetailRows.Clear();
        LogFiles.Clear();
        LogFileTree.Clear();
        SelectedEntry = null;

        try
        {

            var files = args.GetMultipleFiles(200);
            var relativePaths = Array.Empty<string>();
            if (FolderInput is not null)
            {
                if (jsModule is not null)
                {
                    relativePaths = await jsModule.InvokeAsync<string[]>(
                        "getRelativePaths",
                        FolderInput.Element
                    );
                }
            }
            LogFileEntry? firstLogFile = null;
            for (var i = 0; i < files.Count; i++)
            {
                var file = files[i];
                if (!file.Name.EndsWith(".log", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                var relativePath = i < relativePaths.Length ? relativePaths[i] : file.Name;
                if (string.IsNullOrWhiteSpace(relativePath))
                {
                    relativePath = file.Name;
                }

                var entry = new LogFileEntry(file.Name, file, relativePath);
                LogFiles.Add(entry);
                firstLogFile ??= entry;
            }

            if (LogFiles.Count == 0)
            {
                ParseWarnings.Add("No .log files found in the selected folder.");
                return;
            }

            UploadedFileName = $"{LogFiles.Count} log file(s) found";
            BuildLogFileTree();
        }
        catch (Exception ex)
        {
            ParseWarnings.Add($"Unable to parse file: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
        }
    }
}

<MudContainer MaxWidth="MaxWidth.False" Class="py-6 acl-parser-page">
    <MudGrid GutterSize="3">
        <MudItem xs="12" md="3" lg="2">
            <MudPaper Elevation="2" Class="p-4">
                <MudStack Spacing="2">
                    <MudText Typo="Typo.h5" Class="font-weight-bold">Cisco ACL Parser</MudText>
                    <MudText Typo="Typo.body2" Class="text-secondary">
                        Drop a Cisco ACL config file to extract source, destination, protocol, and rule metadata.
                    </MudText>
                    <MudStack Spacing="2" >
                        <div class="acl-drop-zone">
                            <InputFile @ref="FolderInput"
                                       OnChange="HandleFolderSelected"
                                       class="acl-drop-input"
                                       accept=".log,.txt,.cfg,.conf,.acl"
                                       multiple
                                       webkitdirectory />
                            <div class="acl-drop-content">
                                <MudIcon Icon="@Icons.Material.Filled.FolderOpen" Class="acl-drop-icon" />
                                <MudText Typo="Typo.h6" Class="font-weight-bold">Choose a log folder</MudText>
                                <MudText Typo="Typo.subtitle2" Class="acl-drop-hint">Drag a folder here or click to browse</MudText>
                            </div>
                        </div>
                        <MudPaper Elevation="0" Class="acl-file-panel">
                            <MudStack Spacing="1">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                    <MudText Typo="Typo.subtitle2" Class="font-weight-bold">Log files</MudText>
                                    @if (LogFiles.Count > 0)
                                    {
                                        <MudChip T="string" Variant="Variant.Outlined" Size="Size.Small">
                                            @LogFiles.Count
                                        </MudChip>
                                    }
                                </MudStack>
                                @if (LogFileTree.Count > 0)
                                {
                                    <MudList T="LogTreeNode" Dense="true" Class="acl-file-tree">
                                        @RenderLogTree(LogFileTree, 0)
                                    </MudList>
                                }
                                else if (LogFiles.Count > 0)
                                {
                                    <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">
                                        Unable to render folder tree. Showing flat file list instead.
                                    </MudAlert>
                                    <MudList T="LogFileEntry" Dense="true" Class="acl-file-tree">
                                        @foreach (var file in LogFiles)
                                        {
                                            <MudListItem T="LogFileEntry"
                                                         OnClick="@(() => SelectLogFile(file))"
                                                         Class="@(UploadedFileName == file.DisplayName ? "acl-file-active" : string.Empty)">
                                                <MudText Typo="Typo.body2">@file.RelativePath</MudText>
                                            </MudListItem>
                                        }
                                    </MudList>
                                }
                                else
                                {
                                    <MudText Typo="Typo.caption" Class="text-secondary">
                                        Select a folder to list available .log files.
                                    </MudText>
                                }
                            </MudStack>
                        </MudPaper>
                    </MudStack>
                    @if (IsLoading)
                    {
                        <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                    }
                    else if (Entries.Count > 0)
                    {
                    }
                    @if (ParseWarnings.Count > 0)
                    {
                        <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">
                            @foreach (var warning in ParseWarnings)
                            {
                                <div>@warning</div>
                            }
                        </MudAlert>
                    }
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="9" lg="10" Class="acl-right-column">
            <MudStack Spacing="3" Class="acl-right-stack">
                <MudPaper Elevation="2" Class="p-4 acl-panel acl-panel-scroll">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Wrap="Wrap.Wrap" Class="acl-rules-header">
                        <MudStack Row="true" AlignItems="AlignItems.Baseline" Wrap="Wrap.Wrap" Spacing="1">
                            @if (!string.IsNullOrWhiteSpace(UploadedFileName))
                            {
                                <MudText Typo="Typo.h4" Class="font-weight-bold acl-rules-title">@UploadedFileName</MudText>
                            }
                        </MudStack>
                        @if (Entries.Count > 0)
                        {
                            <MudPaper Elevation="0" Class="acl-violation-summary">
                                <MudStack Spacing="1">
                                    <MudText Typo="Typo.caption" Class="font-weight-bold">Violation Summary</MudText>
                                    <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center" Wrap="Wrap.Wrap">
                                        <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">
                                            <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                                                <MudText Typo="Typo.caption">Any</MudText>
                                                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Size="Size.Small" />
                                                <MudText Typo="Typo.caption">Any: @AnyAnyViolationCount</MudText>
                                            </MudStack>
                                        </MudChip>
                                        <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">
                                            Cross-zone: @CrossZoneViolationCount
                                        </MudChip>
                                        <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">
                                            Over-permissive: @OverPermissiveViolationCount
                                        </MudChip>
                                        <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">
                                            Insecure service: @InsecureServiceViolationCount
                                        </MudChip>
                                    </MudStack>
                                </MudStack>
                            </MudPaper>
                        }
                    </MudStack>

                    <MudTable Items="Entries"
                              Dense="true"
                              Hover="true"
                              Striped="true"
                              RowClassFunc="GetRowClass"
                              OnRowClick="@((TableRowClickEventArgs<AclEntry> args) => HandleRowClick(args))"
                              FixedHeader="true"
                              Height="var(--acl-table-height)">
                        <HeaderContent>
                            <MudTh>#</MudTh>
                            <MudTh>ACL Name</MudTh>
                            <MudTh>Interface</MudTh>
                            <MudTh>Action</MudTh>
                            <MudTh>Protocol</MudTh>
                            <MudTh>Source</MudTh>
                            <MudTh>Dest</MudTh>
                            <MudTh>Dest Port</MudTh>
                            <MudTh>Remark</MudTh>
                            <MudTh></MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            @{
                                var ruleViolations = GetRuleViolations(context);
                            }
                            <MudTd DataLabel="#">@context.Occurrence</MudTd>
                            <MudTd DataLabel="ACL Name">@context.AclName</MudTd>
                            <MudTd DataLabel="Interface">@context.Interface</MudTd>
                            <MudTd DataLabel="Action">
                                <MudChip T="string" Color="@GetActionColor(context.Action)" Variant="Variant.Filled" Size="Size.Small">
                                    @context.Action
                                </MudChip>
                            </MudTd>
                            <MudTd DataLabel="Protocol">@context.Protocol</MudTd>
                            <MudTd DataLabel="Source">@context.Source</MudTd>
                            <MudTd DataLabel="Dest">@context.Destination</MudTd>
                            <MudTd DataLabel="Dest Port">@context.DestinationPort</MudTd>
                            <MudTd DataLabel="Remark">@context.Remark</MudTd>
                            <MudTd DataLabel="Violations">
                                @if (ruleViolations.Count > 0)
                                {
                                    <MudTooltip Text="@string.Join(", ", ruleViolations)">
                                        <MudIcon Icon="@Icons.Material.Filled.ReportProblem"
                                                 Color="Color.Warning"
                                                 Size="Size.Small" />
                                    </MudTooltip>
                                }
                            </MudTd>
                        </RowTemplate>
                        <NoRecordsContent>
                            <MudText Typo="Typo.body2" Class="text-secondary">Upload a config to see parsed ACL rules.</MudText>
                        </NoRecordsContent>
                    </MudTable>

                </MudPaper>

                <MudPaper Elevation="2" Class="p-4 acl-panel acl-panel-scroll">
                    <MudText Typo="Typo.subtitle1" Class="font-weight-bold mb-2">Rule Details</MudText>
                    <div class="acl-detail-scroll" @ref="DetailScrollRef">
                        <svg class="acl-cross-zone-svg" aria-hidden="true"></svg>
                        <MudTable Items="DetailRows" Dense="true" Hover="true" Striped="false" Class="acl-detail-table" FixedHeader="true" Height="var(--acl-table-height)">
                            <HeaderContent>
                                <MudTh>Protocol Info</MudTh>
                                <MudTh>Source Info</MudTh>
                                <MudTh>Destination Info</MudTh>
                                <MudTh>Dest. Port Info</MudTh>
                            </HeaderContent>
                            <RowTemplate>
                                @{
                                    var hasInsecureService = context.Violations.Contains("Insecure service");
                                    var hasOverPermissive = context.Violations.Contains("Over-permissive");
                                    var destMarkerClass = string.IsNullOrWhiteSpace(context.DestinationPrefix)
                                        ? "acl-cross-zone-dest-marker acl-cross-zone-dest-marker-root"
                                        : "acl-cross-zone-dest-marker";
                                    var protocolInsecureMatches = hasInsecureService
                                        ? GetInsecureServiceMatches(context.ProtocolInfo)
                                        : Array.Empty<InsecureMatch>();
                                    var destinationPortInsecureMatches = hasInsecureService &&
                                            !string.IsNullOrWhiteSpace(context.DestinationPortInfo) &&
                                            !context.DestinationPortInfo.Equals("Not set", StringComparison.OrdinalIgnoreCase)
                                        ? GetInsecureServiceMatches(context.DestinationPortInfo)
                                        : Array.Empty<InsecureMatch>();
                                }
                                <MudTd DataLabel="Protocol Info">
                                    <div class="acl-detail-cell">
                                        <span class="acl-tree-prefix">@context.ProtocolPrefix</span>@context.ProtocolInfo
                                        @if (protocolInsecureMatches.Count > 0)
                                        {
                                            <span class="acl-detail-warning">
                                                <MudTooltip Text="@BuildInsecureServiceTooltip(protocolInsecureMatches)">
                                                    <MudIcon Icon="@Icons.Material.Filled.ReportProblem" Color="Color.Warning" Size="Size.Small" />
                                                </MudTooltip>
                                            </span>
                                        }
                                    </div>
                                </MudTd>
                                <MudTd DataLabel="Source Info">
                                    <div class="acl-detail-cell">
                                        <span class="acl-tree-prefix">@context.SourcePrefix</span>@context.SourceInfo@if (!string.IsNullOrWhiteSpace(context.SourceCrossZonePairs))
                                        {
                                            <MudTooltip Text="@BuildCrossZoneTooltip(context.SourceCrossZonePairs)">
                                                <span class="acl-cross-zone-source-marker" data-cross-zone-pairs="@context.SourceCrossZonePairs"></span>
                                            </MudTooltip>
                                        }
                                        else
                                        {
                                            <span class="acl-cross-zone-source-marker"></span>
                                        }
                                    </div>
                                </MudTd>
                                <MudTd DataLabel="Destination Info">
                                    <div class="acl-detail-cell">
                                        @if (!string.IsNullOrWhiteSpace(context.DestinationCrossZonePairs))
                                        {
                                            <MudTooltip Text="@BuildCrossZoneTooltip(context.DestinationCrossZonePairs)">
                                                <span class="@destMarkerClass" data-cross-zone-pairs="@context.DestinationCrossZonePairs" data-cross-zone-tooltip="@BuildCrossZoneTooltip(context.DestinationCrossZonePairs)"></span>
                                            </MudTooltip>
                                        }
                                        else
                                        {
                                            <span class="@destMarkerClass"></span>
                                        }
                                        <span class="acl-tree-prefix">@context.DestinationPrefix</span>@context.DestinationInfo
                                        @if (hasOverPermissive)
                                        {
                                            <span class="acl-detail-warning">
                                                <MudTooltip Text="Over-permissive">
                                                    <MudIcon Icon="@Icons.Material.Filled.ReportProblem" Color="Color.Warning" Size="Size.Small" />
                                                </MudTooltip>
                                            </span>
                                        }
                                    </div>
                                </MudTd>
                                <MudTd DataLabel="Dest. Port Info">
                                    <div class="acl-detail-cell">
                                        <span class="acl-tree-prefix">@context.DestinationPortPrefix</span>@context.DestinationPortInfo
                                        @if (destinationPortInsecureMatches.Count > 0)
                                        {
                                            <span class="acl-detail-warning">
                                                <MudTooltip Text="@BuildInsecureServiceTooltip(destinationPortInsecureMatches)">
                                                    <MudIcon Icon="@Icons.Material.Filled.ReportProblem" Color="Color.Warning" Size="Size.Small" />
                                                </MudTooltip>
                                            </span>
                                        }
                                    </div>
                                </MudTd>
                            </RowTemplate>
                            <NoRecordsContent>
                                <MudText Typo="Typo.body2" Class="text-secondary">Select a rule to view details.</MudText>
                            </NoRecordsContent>
                        </MudTable>
                    </div>
                </MudPaper>
            </MudStack>
        </MudItem>
    </MudGrid>
</MudContainer>




@code {
    private IJSObjectReference jsModule { get; set; } = null!;
    private static readonly ViolationSettings ViolationConfig = new(
        crossZonePairs: new[]
        {
            new CrossZoneRule("10.17.0.0", "10.18.0.0", 16),
            new CrossZoneRule("10.206.40.0", "10.206.56.0", 24)
        },
        overPermissiveRootSubnets: new[]
        {
            new SubnetRule("10.0.0.0", 8),
            new SubnetRule("192.0.0.0", 8)
        },
        overPermissiveMaxPrefixLength: 16,
        smallSourceMinPrefixLength: 16,
        insecureServicePorts: new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
        {
            ["ftp"] = 21,
            ["ftp-data"] = 20,
            ["telnet"] = 23,
            ["tftp"] = 69,
            ["snmp"] = 161,
            ["snmptrap"] = 162,
            ["rlogin"] = 513,
            ["rsh"] = 514
        });

    private readonly List<AclEntry> Entries = new();
    private readonly List<string> ParseWarnings = new();
    private readonly List<AclDetailRow> DetailRows = new();
    private readonly Dictionary<string, List<string>> NetworkObjectGroups = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<string>> NetworkObjects = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<string>> ServiceObjectGroups = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<string>> ServiceObjects = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, string> ServiceObjectGroupProtocols = new(StringComparer.OrdinalIgnoreCase);
    private readonly List<LogFileEntry> LogFiles = new();
    private readonly List<TreeItemData<LogTreeNode>> LogFileTree = new();
    private string? UploadedFileName;
    private DateTime? UploadedAt;
    private bool IsLoading;
    private AclEntry? SelectedEntry;
    private InputFile? FolderInput;
    private ElementReference DetailScrollRef;
    private bool _pendingSplineLayout;



    private async Task SelectLogFile(LogFileEntry entry)
    {
        await LoadLogFile(entry.File);
    }

    private async Task OnLogTreeSelected(LogTreeNode node)
    {
        if (node.IsFolder || node.FileEntry is null)
        {
            return;
        }

        await LoadLogFile(node.FileEntry.File);
    }

    private async Task LoadLogFile(IBrowserFile file)
    {
        Entries.Clear();
        ParseWarnings.Clear();
        NetworkObjectGroups.Clear();
        NetworkObjects.Clear();
        ServiceObjectGroups.Clear();
        ServiceObjects.Clear();
        ServiceObjectGroupProtocols.Clear();

        await using var stream = file.OpenReadStream(maxAllowedSize: 10_000_000);
        using var reader = new StreamReader(stream);
        var content = await reader.ReadToEndAsync();

        UploadedFileName = file.Name;
        UploadedAt = DateTime.Now;
        ParseNetworkObjectGroups(content);
        ParseNetworkObjects(content);
        ParseServiceObjectGroups(content);
        ParseServiceObjects(content);
        Entries.AddRange(ParseAcl(content));
        SelectedEntry = Entries.FirstOrDefault();
        BuildDetailRows();
    }

    private void BuildLogFileTree()
    {
        LogFileTree.Clear();

        foreach (var entry in LogFiles.OrderBy(file => file.RelativePath, StringComparer.OrdinalIgnoreCase))
        {
            var normalized = entry.RelativePath.Replace('\\', '/');
            var segments = normalized.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);
            if (segments.Length == 0)
            {
                continue;
            }

            var currentLevel = LogFileTree;
            for (var i = 0; i < segments.Length; i++)
            {
                var segment = segments[i];
                var isFile = i == segments.Length - 1;

                if (isFile)
                {
                    currentLevel.Add(new TreeItemData<LogTreeNode>
                    {
                        Text = segment,
                        Icon = Icons.Material.Filled.Description,
                        Value = new LogTreeNode(segment, false, entry),
                        Expandable = false
                    });
                    break;
                }

                var existing = currentLevel.FirstOrDefault(node =>
                    node.Value is not null &&
                    node.Value.IsFolder &&
                    node.Value.Name.Equals(segment, StringComparison.OrdinalIgnoreCase));

                if (existing is null)
                {
                    existing = new TreeItemData<LogTreeNode>
                    {
                        Text = segment,
                        Icon = Icons.Material.Filled.Folder,
                        Value = new LogTreeNode(segment, true, null),
                        Expanded = false,
                        Expandable = true,
                        Children = new List<TreeItemData<LogTreeNode>>()
                    };
                    currentLevel.Add(existing);
                }

                existing.Expandable = true;
                currentLevel = existing.Children ??= new List<TreeItemData<LogTreeNode>>();
            }
        }

        SortTreeNodes(LogFileTree);
    }

    private RenderFragment RenderLogTree(IEnumerable<TreeItemData<LogTreeNode>> nodes, int depth) => builder =>
    {
        var sequence = 0;
        foreach (var node in nodes)
        {
            var isFolder = node.Value?.IsFolder == true;
            var isActive = !isFolder && node.Value?.FileEntry?.DisplayName == UploadedFileName;

            builder.OpenComponent<MudListItem<LogTreeNode>>(sequence++);
            builder.AddAttribute(sequence++, "Class", $"acl-tree-row{(isActive ? " acl-file-active" : string.Empty)}");
            builder.AddAttribute(sequence++, "Style", $"--depth:{depth}");
            if (isFolder && node.Value is not null)
            {
                builder.AddAttribute(sequence++, "OnClick",
                    EventCallback.Factory.Create<MouseEventArgs>(this, (MouseEventArgs _) => ToggleFolder(node.Value)));
            }
            else if (!isFolder && node.Value?.FileEntry is not null)
            {
                builder.AddAttribute(sequence++, "OnClick",
                    EventCallback.Factory.Create<MouseEventArgs>(this, (MouseEventArgs _) => SelectLogFile(node.Value.FileEntry)));
            }

            builder.AddAttribute(sequence++, "ChildContent", (RenderFragment)(childBuilder =>
            {
                childBuilder.OpenElement(sequence++, "div");
                childBuilder.AddAttribute(sequence++, "class", $"acl-tree-item{(isFolder ? " acl-tree-folder" : string.Empty)}");
                if (isFolder && node.Value is not null)
                {
                    childBuilder.OpenComponent<MudIcon>(sequence++);
                    childBuilder.AddAttribute(sequence++, "Icon", node.Value.IsExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight);
                    childBuilder.AddAttribute(sequence++, "Size", Size.Small);
                    childBuilder.CloseComponent();
                }

                childBuilder.OpenComponent<MudIcon>(sequence++);
                childBuilder.AddAttribute(sequence++, "Icon", isFolder ? Icons.Material.Filled.Folder : Icons.Material.Filled.Description);
                childBuilder.AddAttribute(sequence++, "Size", Size.Small);
                childBuilder.CloseComponent();
                childBuilder.OpenElement(sequence++, "span");
                childBuilder.AddAttribute(sequence++, "class", "acl-tree-text");
                childBuilder.AddContent(sequence++, string.IsNullOrWhiteSpace(node.Text) ? "(unnamed)" : node.Text);
                childBuilder.CloseElement();
                childBuilder.CloseElement();
            }));
            builder.CloseComponent();

            if (node.Children is not null && node.Children.Count > 0 && (node.Value?.IsExpanded ?? true))
            {
                builder.AddContent(sequence++, RenderLogTree(node.Children, depth + 1));
            }
        }
    };

    private void ToggleFolder(LogTreeNode node)
    {
        node.IsExpanded = !node.IsExpanded;
        StateHasChanged();
    }

    private static void SortTreeNodes(List<TreeItemData<LogTreeNode>> nodes)
    {
        nodes.Sort((left, right) =>
        {
            var leftIsFolder = left.Value?.IsFolder ?? false;
            var rightIsFolder = right.Value?.IsFolder ?? false;

            if (leftIsFolder != rightIsFolder)
            {
                return leftIsFolder ? -1 : 1;
            }

            return string.Compare(left.Text, right.Text, StringComparison.OrdinalIgnoreCase);
        });

        foreach (var node in nodes)
        {
            if (node.Children is not null && node.Children.Count > 0)
            {
                SortTreeNodes(node.Children);
            }
        }
    }
    private IEnumerable<AclEntry> ParseAcl(string content)
    {
        var results = new List<AclEntry>();
        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentAclName = null;
        var inNamedAcl = false;
        string? pendingRemark = null;
        string? pendingRemarkAcl = null;

        for (var i = 0; i < lines.Length; i++)
        {
            var rawLine = lines[i];
            var lineNumber = i + 1;
            var trimmed = rawLine.Trim();

            if (string.IsNullOrWhiteSpace(trimmed))
            {
                continue;
            }

            if (trimmed.StartsWith("!", StringComparison.Ordinal) || trimmed.StartsWith("#", StringComparison.Ordinal))
            {
                continue;
            }

            var tokens = Tokenize(trimmed);
            if (tokens.Length == 0)
            {
                continue;
            }

            if (tokens.Length >= 3 &&
                tokens[0].Equals("ip", StringComparison.OrdinalIgnoreCase) &&
                tokens[1].Equals("access-list", StringComparison.OrdinalIgnoreCase))
            {
                if (tokens.Length >= 4)
                {
                    currentAclName = tokens[3];
                    inNamedAcl = true;
                }

                continue;
            }

            if (tokens[0].Equals("exit", StringComparison.OrdinalIgnoreCase) ||
                tokens[0].Equals("end", StringComparison.OrdinalIgnoreCase))
            {
                currentAclName = null;
                inNamedAcl = false;
                continue;
            }

            var entry = TryParseAclEntry(tokens, lineNumber, trimmed, currentAclName, inNamedAcl);
            if (entry is null)
            {
                if (LooksLikeAclLine(tokens))
                {
                    ParseWarnings.Add($"Line {lineNumber}: Unrecognized ACL syntax.");
                }
                continue;
            }

            if (entry.Action.Equals("remark", StringComparison.OrdinalIgnoreCase))
            {
                if (!string.IsNullOrWhiteSpace(entry.Remark))
                {
                    pendingRemark = string.IsNullOrWhiteSpace(pendingRemark)
                        ? entry.Remark
                        : $"{pendingRemark} / {entry.Remark}";

                    if (!string.IsNullOrWhiteSpace(entry.AclName))
                    {
                        pendingRemarkAcl = entry.AclName;
                    }
                }
                continue;
            }

            if (!string.IsNullOrWhiteSpace(pendingRemark))
            {
                if (string.IsNullOrWhiteSpace(pendingRemarkAcl) ||
                    entry.AclName.Equals(pendingRemarkAcl, StringComparison.OrdinalIgnoreCase))
                {
                    entry = entry with
                    {
                        Remark = string.IsNullOrWhiteSpace(entry.Remark)
                            ? pendingRemark
                            : $"{pendingRemark} / {entry.Remark}"
                    };
                }

                pendingRemark = null;
                pendingRemarkAcl = null;
            }

            results.Add(entry with { Occurrence = results.Count + 1 });
        }

        return results;
    }

    private void ParseNetworkObjectGroups(string content)
    {
        NetworkObjectGroups.Clear();

        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentGroup = null;

        foreach (var rawLine in lines)
        {
            var trimmed = rawLine.Trim();
            if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith("!", StringComparison.Ordinal))
            {
                continue;
            }

            if (trimmed.StartsWith("object-group network ", StringComparison.OrdinalIgnoreCase))
            {
                var tokens = Tokenize(trimmed);
                if (tokens.Length >= 3)
                {
                    currentGroup = tokens[2];
                    if (!NetworkObjectGroups.ContainsKey(currentGroup))
                    {
                        NetworkObjectGroups[currentGroup] = new List<string>();
                    }
                }
                continue;
            }

            if (currentGroup is null)
            {
                continue;
            }

            if (!IsIndentedLine(rawLine))
            {
                currentGroup = null;
                continue;
            }

            if (trimmed.StartsWith("network-object ", StringComparison.OrdinalIgnoreCase))
            {
                var member = trimmed.Substring("network-object ".Length).Trim();
                if (!string.IsNullOrWhiteSpace(member))
                {
                    NetworkObjectGroups[currentGroup].Add(member);
                }
                continue;
            }

            if (trimmed.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase))
            {
                var groupName = trimmed.Substring("group-object ".Length).Trim();
                if (!string.IsNullOrWhiteSpace(groupName))
                {
                    NetworkObjectGroups[currentGroup].Add($"group-object {groupName}");
                }
            }
        }
    }

    private void ParseNetworkObjects(string content)
    {
        NetworkObjects.Clear();

        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentObject = null;

        foreach (var rawLine in lines)
        {
            var trimmed = rawLine.Trim();
            if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith("!", StringComparison.Ordinal))
            {
                continue;
            }

            if (trimmed.StartsWith("object network ", StringComparison.OrdinalIgnoreCase))
            {
                var tokens = Tokenize(trimmed);
                if (tokens.Length >= 3)
                {
                    currentObject = tokens[2];
                    if (!NetworkObjects.ContainsKey(currentObject))
                    {
                        NetworkObjects[currentObject] = new List<string>();
                    }
                }
                continue;
            }

            if (currentObject is null)
            {
                continue;
            }

            if (!IsIndentedLine(rawLine))
            {
                currentObject = null;
                continue;
            }

            NetworkObjects[currentObject].Add(trimmed);
        }
    }

    private void ParseServiceObjectGroups(string content)
    {
        ServiceObjectGroups.Clear();
        ServiceObjectGroupProtocols.Clear();

        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentGroup = null;

        foreach (var rawLine in lines)
        {
            var trimmed = rawLine.Trim();
            if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith("!", StringComparison.Ordinal))
            {
                continue;
            }

            if (trimmed.StartsWith("object-group service ", StringComparison.OrdinalIgnoreCase))
            {
                var tokens = Tokenize(trimmed);
                if (tokens.Length >= 3)
                {
                    currentGroup = tokens[2];
                    if (!ServiceObjectGroups.ContainsKey(currentGroup))
                    {
                        ServiceObjectGroups[currentGroup] = new List<string>();
                    }

                    if (tokens.Length >= 4)
                    {
                        ServiceObjectGroupProtocols[currentGroup] = tokens[3];
                    }
                }
                continue;
            }

            if (currentGroup is null)
            {
                continue;
            }

            if (!IsIndentedLine(rawLine))
            {
                currentGroup = null;
                continue;
            }

            if (trimmed.StartsWith("port-object ", StringComparison.OrdinalIgnoreCase) ||
                trimmed.StartsWith("service-object ", StringComparison.OrdinalIgnoreCase) ||
                trimmed.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase) ||
                trimmed.StartsWith("object ", StringComparison.OrdinalIgnoreCase) ||
                trimmed.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
            {
                ServiceObjectGroups[currentGroup].Add(trimmed);
                continue;
            }

            ServiceObjectGroups[currentGroup].Add(trimmed);
        }
    }

    private void ParseServiceObjects(string content)
    {
        ServiceObjects.Clear();

        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentObject = null;

        foreach (var rawLine in lines)
        {
            var trimmed = rawLine.Trim();
            if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith("!", StringComparison.Ordinal))
            {
                continue;
            }

            if (trimmed.StartsWith("object service ", StringComparison.OrdinalIgnoreCase))
            {
                var tokens = Tokenize(trimmed);
                if (tokens.Length >= 3)
                {
                    currentObject = tokens[2];
                    if (!ServiceObjects.ContainsKey(currentObject))
                    {
                        ServiceObjects[currentObject] = new List<string>();
                    }
                }
                continue;
            }

            if (currentObject is null)
            {
                continue;
            }

            if (!IsIndentedLine(rawLine))
            {
                currentObject = null;
                continue;
            }

            ServiceObjects[currentObject].Add(trimmed);
        }
    }

    private static string[] Tokenize(string line)
    {
        return line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    }

    private static bool LooksLikeAclLine(string[] tokens)
    {
        if (tokens.Length == 0)
        {
            return false;
        }

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (IsSequenceNumber(tokens[0]) && tokens.Length > 1)
        {
            var actionAfterSequence = tokens[1];
            return IsActionToken(actionAfterSequence) || actionAfterSequence.Equals("remark", StringComparison.OrdinalIgnoreCase);
        }

        var action = tokens[0];
        return IsActionToken(action) || action.Equals("remark", StringComparison.OrdinalIgnoreCase);
    }

    private static AclEntry? TryParseAclEntry(string[] tokens, int lineNumber, string raw, string? currentAclName, bool inNamedAcl)
    {
        var index = 0;
        var aclName = currentAclName;

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            if (tokens.Length < 3)
            {
                return null;
            }

            aclName = tokens[1];
            index = 2;
        }
        else if (!IsActionToken(tokens[0]) && !tokens[0].Equals("remark", StringComparison.OrdinalIgnoreCase))
        {
            if (!inNamedAcl)
            {
                return null;
            }

            index = 0;
        }

        if (index < tokens.Length && tokens[index].Equals("line", StringComparison.OrdinalIgnoreCase))
        {
            if (index + 1 < tokens.Length && IsSequenceNumber(tokens[index + 1]))
            {
                index += 2;
            }
        }

        if (index < tokens.Length && IsSequenceNumber(tokens[index]))
        {
            index++;
        }

        if (index < tokens.Length && IsAclTypeToken(tokens[index]))
        {
            index++;
        }

        if (index >= tokens.Length)
        {
            return null;
        }

        var action = tokens[index].ToLowerInvariant();
        if (action == "remark")
        {
            var comment = string.Join(' ', tokens.Skip(index + 1));
            return new AclEntry(
                lineNumber,
                0,
                raw,
                aclName ?? string.Empty,
                string.Empty,
                action,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                comment,
                false);
        }

        if (!IsActionToken(action))
        {
            return null;
        }

        index++;
        var protocol = index < tokens.Length ? tokens[index].ToLowerInvariant() : "ip";
        if (protocol is "object" or "object-group")
        {
            if (index + 1 < tokens.Length)
            {
                protocol = $"{protocol} {tokens[index + 1]}";
                index += 2;
            }
            else
            {
                index++;
            }
        }
        else
        {
            index++;
        }

        var (source, afterSource) = ParseAddress(tokens, index);
        index = afterSource;

        var (sourcePort, afterSourcePort) = ParsePort(tokens, index);
        if (afterSourcePort != index)
        {
            index = afterSourcePort;
        }

        var (destination, afterDestination) = ParseAddress(tokens, index);
        index = afterDestination;

        var (destinationPort, afterDestinationPort) = ParsePort(tokens, index);
        if (afterDestinationPort != index)
        {
            index = afterDestinationPort;
        }

        var options = index < tokens.Length ? string.Join(' ', tokens.Skip(index)) : string.Empty;
        var log = ContainsLog(tokens, index);
        var iface = ExtractInterface(source, destination, options);

        return new AclEntry(
            lineNumber,
            0,
            raw,
            aclName ?? string.Empty,
            iface,
            action,
            protocol,
            source,
            sourcePort,
            destination,
            destinationPort,
            options,
            string.Empty,
            log);
    }

    private static (string Value, int NextIndex) ParseAddress(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start];
        if (token.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            return ("any", start + 1);
        }

        if (token.Equals("host", StringComparison.OrdinalIgnoreCase) && start + 1 < tokens.Length)
        {
            return ($"host {tokens[start + 1]}", start + 2);
        }

        if ((token.Equals("object", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("object-group", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("interface", StringComparison.OrdinalIgnoreCase)) &&
            start + 1 < tokens.Length)
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (LooksLikeIp(token) && start + 1 < tokens.Length && LooksLikeIp(tokens[start + 1]))
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (token.Contains('/', StringComparison.Ordinal))
        {
            return (token, start + 1);
        }

        return (token, start + 1);
    }

    private static (string Value, int NextIndex) ParsePort(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start].ToLowerInvariant();
        if (token is "eq" or "gt" or "lt" or "neq")
        {
            return start + 1 < tokens.Length
                ? ($"{token} {tokens[start + 1]}", start + 2)
                : (token, start + 1);
        }

        if (token == "range")
        {
            return start + 2 < tokens.Length
                ? ($"{token} {tokens[start + 1]} {tokens[start + 2]}", start + 3)
                : (token, start + 1);
        }

        return (string.Empty, start);
    }

    private static bool IsActionToken(string token)
    {
        return token.Equals("permit", StringComparison.OrdinalIgnoreCase) ||
               token.Equals("deny", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsAclTypeToken(string token)
    {
        return token.Equals("extended", StringComparison.OrdinalIgnoreCase) ||
               token.Equals("standard", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsSequenceNumber(string token)
    {
        return int.TryParse(token, out _);
    }

    private static bool LooksLikeIp(string token)
    {
        return System.Net.IPAddress.TryParse(token, out _);
    }

    private static bool ContainsLog(string[] tokens, int start)
    {
        for (var i = start; i < tokens.Length; i++)
        {
            if (tokens[i].Equals("log", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }

        return false;
    }

    private static string ExtractInterface(string source, string destination, string options)
    {
        if (source.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            return source.Substring("interface ".Length);
        }

        if (destination.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            return destination.Substring("interface ".Length);
        }

        if (options.Contains("interface ", StringComparison.OrdinalIgnoreCase))
        {
            var parts = options.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            for (var i = 0; i < parts.Length - 1; i++)
            {
                if (parts[i].Equals("interface", StringComparison.OrdinalIgnoreCase))
                {
                    return parts[i + 1];
                }
            }
        }

        return string.Empty;
    }

    private static bool IsIndentedLine(string line)
    {
        return !string.IsNullOrEmpty(line) && char.IsWhiteSpace(line[0]);
    }

    private static Color GetActionColor(string action)
    {
        return action switch
        {
            "permit" => Color.Success,
            "deny" => Color.Error,
            "remark" => Color.Default,
            _ => Color.Info
        };
    }

    private string GetRowClass(AclEntry entry, int index)
    {
        var baseClass = entry.Action switch
        {
            "deny" => "acl-row-deny",
            "remark" => "acl-row-remark",
            _ => string.Empty
        };

        if (SelectedEntry is not null && entry.Occurrence == SelectedEntry.Occurrence)
        {
            return string.IsNullOrWhiteSpace(baseClass) ? "acl-row-selected" : $"{baseClass} acl-row-selected";
        }

        return baseClass;
    }

    private void HandleRowClick(TableRowClickEventArgs<AclEntry> args)
    {
        SelectedEntry = args.Item;
        BuildDetailRows();
    }

    private void BuildDetailRows()
    {
        DetailRows.Clear();

        if (SelectedEntry is null)
        {
            return;
        }

        var protocolNodes = DescribeProtocolNodes(SelectedEntry);
        var sourceNodes = DescribeAddressNodes(SelectedEntry.Source);
        var destinationNodes = DescribeAddressNodes(SelectedEntry.Destination);
        var portNodes = DescribeDestinationPortNodes(SelectedEntry);
        var protocolPrefixes = ComputeTreePrefixes(protocolNodes);
        var sourcePrefixes = ComputeTreePrefixes(sourceNodes);
        var destinationPrefixes = ComputeTreePrefixes(destinationNodes);
        var portPrefixes = ComputeTreePrefixes(portNodes);
        var activeCrossZonePairs = GetActiveCrossZonePairs(SelectedEntry);
        var sourceCrossZonePairs = BuildCrossZonePairTags(sourceNodes, activeCrossZonePairs);
        var destinationCrossZonePairs = BuildCrossZonePairTags(destinationNodes, activeCrossZonePairs);

        var maxRows = new[] { protocolNodes.Count, sourceNodes.Count, destinationNodes.Count, portNodes.Count }.Max();
        for (var i = 0; i < maxRows; i++)
        {
            var protocolNode = GetNodeAt(protocolNodes, i);
            var sourceNode = GetNodeAt(sourceNodes, i);
            var destinationNode = GetNodeAt(destinationNodes, i);
            var portNode = GetNodeAt(portNodes, i);
            var rowContext = new DetailRowContext(protocolNode.Text, sourceNode.Text, destinationNode.Text, portNode.Text);
            var violations = GetRowViolations(SelectedEntry, rowContext);

            DetailRows.Add(new AclDetailRow(
                protocolNode.Text,
                GetPrefixAt(protocolPrefixes, i),
                sourceNode.Text,
                GetPrefixAt(sourcePrefixes, i),
                destinationNode.Text,
                GetPrefixAt(destinationPrefixes, i),
                portNode.Text,
                GetPrefixAt(portPrefixes, i),
                violations,
                GetTagAt(sourceCrossZonePairs, i),
                GetTagAt(destinationCrossZonePairs, i)));
        }

        _pendingSplineLayout = true;
    }

    private List<DetailNode> DescribeProtocolNodes(AclEntry entry)
    {
        var nodes = new List<DetailNode>();

        if (string.IsNullOrWhiteSpace(entry.Protocol))
        {
            nodes.Add(new DetailNode("Not set", 0));
            return nodes;
        }

        if (entry.Protocol.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            var groupName = entry.Protocol.Replace("object-group ", string.Empty, StringComparison.OrdinalIgnoreCase).Trim();
            nodes.Add(new DetailNode($"Service group: {groupName}", 0));
            BuildServiceGroupNodes(groupName, 1, nodes, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
            return nodes;
        }

        if (entry.Protocol.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            var objectName = entry.Protocol.Replace("object ", string.Empty, StringComparison.OrdinalIgnoreCase).Trim();
            nodes.Add(new DetailNode($"Service object: {objectName}", 0));
            AppendServiceObjectNodes(objectName, 1, nodes);
            return nodes;
        }

        nodes.Add(new DetailNode($"Protocol: {entry.Protocol}", 0));
        return nodes;
    }

    private List<DetailNode> DescribeAddressNodes(string address)
    {
        var nodes = new List<DetailNode>();

        if (string.IsNullOrWhiteSpace(address))
        {
            nodes.Add(new DetailNode("Not set", 0));
            return nodes;
        }

        if (address.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            nodes.Add(new DetailNode("Any", 0));
            return nodes;
        }

        if (address.StartsWith("host ", StringComparison.OrdinalIgnoreCase))
        {
            nodes.Add(new DetailNode($"Host: {address.Replace("host ", string.Empty, StringComparison.OrdinalIgnoreCase)}", 0));
            return nodes;
        }

        if (address.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            var groupName = address.Replace("object-group ", string.Empty, StringComparison.OrdinalIgnoreCase).Trim();
            nodes.Add(new DetailNode($"Object group: {groupName}", 0));
            BuildNetworkGroupNodes(groupName, 1, nodes, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
            return nodes;
        }

        if (address.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            var objectName = address.Replace("object ", string.Empty, StringComparison.OrdinalIgnoreCase).Trim();
            nodes.Add(new DetailNode($"Object: {objectName}", 0));
            AppendNetworkObjectNodes(objectName, 1, nodes);
            return nodes;
        }

        if (address.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            nodes.Add(new DetailNode($"Interface: {address.Replace("interface ", string.Empty, StringComparison.OrdinalIgnoreCase)}", 0));
            return nodes;
        }

        nodes.Add(new DetailNode($"Network: {address}", 0));
        return nodes;
    }

    private static List<DetailNode> DescribeDestinationPortNodes(AclEntry entry)
    {
        var nodes = new List<DetailNode>();

        if (!string.IsNullOrWhiteSpace(entry.DestinationPort))
        {
            nodes.Add(new DetailNode($"Port: {entry.DestinationPort}", 0));
            return nodes;
        }

        nodes.Add(new DetailNode("Not set", 0));
        return nodes;
    }

    private void BuildServiceGroupNodes(string groupName, int indentLevel, List<DetailNode> nodes, HashSet<string> visitedGroups)
    {
        if (string.IsNullOrWhiteSpace(groupName))
        {
            return;
        }

        if (!visitedGroups.Add(groupName))
        {
            nodes.Add(new DetailNode($"(cycle detected: {groupName})", indentLevel));
            return;
        }

        if (ServiceObjectGroupProtocols.TryGetValue(groupName, out var protocol) &&
            !string.IsNullOrWhiteSpace(protocol))
        {
            nodes.Add(new DetailNode($"Protocol: {protocol}", indentLevel));
        }

        if (!ServiceObjectGroups.TryGetValue(groupName, out var members))
        {
            nodes.Add(new DetailNode("(group not found)", indentLevel));
            return;
        }

        if (members.Count == 0)
        {
            nodes.Add(new DetailNode("(no members found)", indentLevel));
            return;
        }

        foreach (var member in members)
        {
            if (member.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("group-object ".Length).Trim();
                nodes.Add(new DetailNode($"group-object {nestedName}", indentLevel));
                BuildServiceGroupNodes(nestedName, indentLevel + 1, nodes, visitedGroups);
                continue;
            }

            if (member.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("object-group ".Length).Trim();
                nodes.Add(new DetailNode($"object-group {nestedName}", indentLevel));
                BuildServiceGroupNodes(nestedName, indentLevel + 1, nodes, visitedGroups);
                continue;
            }

            if (member.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
            {
                var objectName = member.Substring("object ".Length).Trim();
                nodes.Add(new DetailNode($"object {objectName}", indentLevel));
                AppendServiceObjectNodes(objectName, indentLevel + 1, nodes);
                continue;
            }

            nodes.Add(new DetailNode(member, indentLevel));
        }
    }

    private void AppendServiceObjectNodes(string objectName, int indentLevel, List<DetailNode> nodes)
    {
        if (!ServiceObjects.TryGetValue(objectName, out var details) || details.Count == 0)
        {
            nodes.Add(new DetailNode("(service object details not found)", indentLevel));
            return;
        }

        foreach (var detail in details)
        {
            nodes.Add(new DetailNode(detail, indentLevel));
        }
    }

    private void BuildNetworkGroupNodes(string groupName, int indentLevel, List<DetailNode> nodes, HashSet<string> visitedGroups)
    {
        if (string.IsNullOrWhiteSpace(groupName))
        {
            return;
        }

        if (!visitedGroups.Add(groupName))
        {
            nodes.Add(new DetailNode($"(cycle detected: {groupName})", indentLevel));
            return;
        }

        if (!NetworkObjectGroups.TryGetValue(groupName, out var members))
        {
            nodes.Add(new DetailNode("(group not found)", indentLevel));
            return;
        }

        if (members.Count == 0)
        {
            nodes.Add(new DetailNode("(no members found)", indentLevel));
            return;
        }

        foreach (var member in members)
        {
            if (member.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("group-object ".Length).Trim();
                nodes.Add(new DetailNode($"group-object {nestedName}", indentLevel));
                BuildNetworkGroupNodes(nestedName, indentLevel + 1, nodes, visitedGroups);
                continue;
            }

            if (member.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
            {
                var objectName = member.Substring("object ".Length).Trim();
                nodes.Add(new DetailNode($"object {objectName}", indentLevel));
                AppendNetworkObjectNodes(objectName, indentLevel + 1, nodes);
                continue;
            }

            if (member.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("object-group ".Length).Trim();
                nodes.Add(new DetailNode($"object-group {nestedName}", indentLevel));
                BuildNetworkGroupNodes(nestedName, indentLevel + 1, nodes, visitedGroups);
                continue;
            }

            nodes.Add(new DetailNode(member, indentLevel));
        }
    }

    private void AppendNetworkObjectNodes(string objectName, int indentLevel, List<DetailNode> nodes)
    {
        if (!NetworkObjects.TryGetValue(objectName, out var details) || details.Count == 0)
        {
            nodes.Add(new DetailNode("(object details not found)", indentLevel));
            return;
        }

        foreach (var detail in details)
        {
            nodes.Add(new DetailNode(detail, indentLevel));
        }
    }

    private static DetailNode GetNodeAt(List<DetailNode> nodes, int index)
    {
        if (index < nodes.Count)
        {
            return nodes[index];
        }

        return new DetailNode(string.Empty, 0);
    }

    private static List<string> ComputeTreePrefixes(List<DetailNode> nodes)
    {
        var prefixes = new List<string>(nodes.Count);
        var lastAtLevel = new List<bool>();

        for (var i = 0; i < nodes.Count; i++)
        {
            var indent = nodes[i].Indent;
            var isLast = IsLastAtIndent(nodes, i);

            while (lastAtLevel.Count < indent)
            {
                lastAtLevel.Add(false);
            }

            if (indent > 0)
            {
                lastAtLevel[indent - 1] = isLast;
            }

            if (indent <= 0)
            {
                prefixes.Add(string.Empty);
                continue;
            }

            var prefix = new StringBuilder();
            prefix.Append("  ");
            for (var level = 0; level < indent - 1; level++)
            {
                prefix.Append(lastAtLevel[level] ? "   " : "\u2502  ");
            }

            prefix.Append(isLast ? "\u2514\u2500" : "\u251C\u2500");
            prefixes.Add(prefix.ToString());
        }

        return prefixes;
    }

    private static bool IsLastAtIndent(List<DetailNode> nodes, int index)
    {
        var indent = nodes[index].Indent;
        for (var i = index + 1; i < nodes.Count; i++)
        {
            var nextIndent = nodes[i].Indent;
            if (nextIndent < indent)
            {
                return true;
            }

            if (nextIndent == indent)
            {
                return false;
            }
        }

        return true;
    }

    private static string GetPrefixAt(List<string> prefixes, int index)
    {
        if (index < prefixes.Count)
        {
            return prefixes[index];
        }

        return string.Empty;
    }

    private IReadOnlyList<string> GetRowViolations(AclEntry entry, DetailRowContext context)
    {
        if (!IsPermit(entry))
        {
            return Array.Empty<string>();
        }

        return ViolationRules
            .Where(rule => rule.AppliesToRow?.Invoke(entry, context) == true)
            .Select(rule => rule.Name)
            .ToList();
    }

    private IReadOnlyList<string> GetRuleViolations(AclEntry entry)
    {
        return ViolationRules
            .Where(rule => rule.AppliesToRule(entry))
            .Select(rule => rule.Name)
            .ToList();
    }

    private HashSet<int> GetActiveCrossZonePairs(AclEntry entry)
    {
        var sources = ExpandAddressInfos(entry.Source).ToList();
        var destinations = ExpandAddressInfos(entry.Destination).ToList();
        var activePairs = new HashSet<int>();

        for (var i = 0; i < ViolationConfig.CrossZonePairs.Count; i++)
        {
            var pair = ViolationConfig.CrossZonePairs[i];
            var crossesForward = sources.Any(source => IsInSubnet(source, pair.SubnetA, pair.PrefixLength)) &&
                                 destinations.Any(destination => IsInSubnet(destination, pair.SubnetB, pair.PrefixLength));
            var crossesReverse = sources.Any(source => IsInSubnet(source, pair.SubnetB, pair.PrefixLength)) &&
                                 destinations.Any(destination => IsInSubnet(destination, pair.SubnetA, pair.PrefixLength));

            if (crossesForward || crossesReverse)
            {
                activePairs.Add(i);
            }
        }

        return activePairs;
    }

    private static string GetTagAt(List<string> tags, int index)
    {
        if (index < tags.Count)
        {
            return tags[index];
        }

        return string.Empty;
    }

    private List<string> BuildCrossZonePairTags(List<DetailNode> nodes, HashSet<int> activePairs)
    {
        var tags = new List<string>(nodes.Count);
        for (var i = 0; i < nodes.Count; i++)
        {
            tags.Add(BuildCrossZonePairTag(nodes[i].Text, activePairs));
        }

        return tags;
    }

    private string BuildCrossZonePairTag(string nodeText, HashSet<int> activePairs)
    {
        if (activePairs.Count == 0 || string.IsNullOrWhiteSpace(nodeText))
        {
            return string.Empty;
        }

        var trimmed = nodeText.Trim();
        if (trimmed.StartsWith("Object group:", StringComparison.OrdinalIgnoreCase) ||
            trimmed.StartsWith("Object:", StringComparison.OrdinalIgnoreCase) ||
            trimmed.StartsWith("Interface:", StringComparison.OrdinalIgnoreCase) ||
            trimmed.Equals("Not set", StringComparison.OrdinalIgnoreCase) ||
            trimmed.Equals("Any", StringComparison.OrdinalIgnoreCase))
        {
            return string.Empty;
        }

        var infos = ExpandAddressInfosForNode(nodeText).ToList();
        if (infos.Count == 0)
        {
            return string.Empty;
        }

        var tokens = new List<string>();
        for (var i = 0; i < ViolationConfig.CrossZonePairs.Count; i++)
        {
            if (!activePairs.Contains(i))
            {
                continue;
            }

            var pair = ViolationConfig.CrossZonePairs[i];
            var inA = infos.Any(info => IsInSubnet(info, pair.SubnetA, pair.PrefixLength));
            var inB = infos.Any(info => IsInSubnet(info, pair.SubnetB, pair.PrefixLength));

            if (inA)
            {
                tokens.Add($"{i}A");
            }

            if (inB)
            {
                tokens.Add($"{i}B");
            }
        }

        return tokens.Count == 0 ? string.Empty : string.Join(',', tokens);
    }

    private string BuildCrossZoneTooltip(string pairTags)
    {
        if (string.IsNullOrWhiteSpace(pairTags))
        {
            return string.Empty;
        }

        var labels = new List<string>();
        var tokens = pairTags.Split(',', StringSplitOptions.RemoveEmptyEntries);
        foreach (var token in tokens)
        {
            var trimmed = token.Trim();
            if (trimmed.Length < 2)
            {
                continue;
            }

            var side = char.ToUpperInvariant(trimmed[^1]);
            if (!int.TryParse(trimmed.Substring(0, trimmed.Length - 1), out var index))
            {
                continue;
            }

            if (index < 0 || index >= ViolationConfig.CrossZonePairs.Count ||
                (side != 'A' && side != 'B'))
            {
                continue;
            }

            var pair = ViolationConfig.CrossZonePairs[index];
            var label = $"{pair.SubnetA}/{pair.PrefixLength} <-> {pair.SubnetB}/{pair.PrefixLength}";
            if (!labels.Contains(label))
            {
                labels.Add(label);
            }
        }

        return labels.Count == 0 ? string.Empty : string.Join(Environment.NewLine, labels);
    }

    private IEnumerable<AddressInfo> ExpandAddressInfosForNode(string nodeText)
    {
        if (string.IsNullOrWhiteSpace(nodeText))
        {
            return Array.Empty<AddressInfo>();
        }

        var trimmed = nodeText.Trim();
        if (trimmed.Equals("Any", StringComparison.OrdinalIgnoreCase))
        {
            return new[] { AddressInfo.Any() };
        }

        if (trimmed.StartsWith("Object group:", StringComparison.OrdinalIgnoreCase))
        {
            var groupName = trimmed.Substring("Object group:".Length).Trim();
            return ExpandGroupMembers(groupName, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
        }

        if (trimmed.StartsWith("Object:", StringComparison.OrdinalIgnoreCase))
        {
            var objectName = trimmed.Substring("Object:".Length).Trim();
            return ExpandNetworkObjectEntries(objectName);
        }

        if (trimmed.StartsWith("Host:", StringComparison.OrdinalIgnoreCase))
        {
            var hostValue = trimmed.Substring("Host:".Length).Trim();
            return new[] { ParseAddressInfo($"host {hostValue}") };
        }

        if (trimmed.StartsWith("Network:", StringComparison.OrdinalIgnoreCase))
        {
            var networkValue = trimmed.Substring("Network:".Length).Trim();
            return new[] { ParseAddressInfo(networkValue) };
        }

        if (trimmed.StartsWith("Interface:", StringComparison.OrdinalIgnoreCase) ||
            trimmed.Equals("Not set", StringComparison.OrdinalIgnoreCase))
        {
            return Array.Empty<AddressInfo>();
        }

        return new[] { ParseAddressInfo(trimmed) };
    }

    private bool IsInsecureServiceViolation(AclEntry entry)
    {
        if (!IsPermit(entry))
        {
            return false;
        }

        if (HasInsecureServiceInText(entry.DestinationPort, entry.Options))
        {
            return true;
        }

        if (entry.Protocol.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            var groupName = entry.Protocol.Substring("object-group ".Length).Trim();
            return ContainsInsecureServiceGroup(groupName, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
        }

        if (entry.Protocol.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            var objectName = entry.Protocol.Substring("object ".Length).Trim();
            return ContainsInsecureServiceObject(objectName);
        }

        return HasInsecureServiceInText(entry.Protocol);
    }

    private bool ContainsInsecureServiceGroup(string groupName, HashSet<string> visitedGroups)
    {
        if (string.IsNullOrWhiteSpace(groupName) || !visitedGroups.Add(groupName))
        {
            return false;
        }

        if (!ServiceObjectGroups.TryGetValue(groupName, out var members))
        {
            return false;
        }

        foreach (var member in members)
        {
            if (member.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("group-object ".Length).Trim();
                if (ContainsInsecureServiceGroup(nestedName, visitedGroups))
                {
                    return true;
                }
                continue;
            }

            if (member.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("object-group ".Length).Trim();
                if (ContainsInsecureServiceGroup(nestedName, visitedGroups))
                {
                    return true;
                }
                continue;
            }

            if (member.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
            {
                var objectName = member.Substring("object ".Length).Trim();
                if (ContainsInsecureServiceObject(objectName))
                {
                    return true;
                }
                continue;
            }

            if (HasInsecureServiceInText(member))
            {
                return true;
            }
        }

        return false;
    }

    private bool ContainsInsecureServiceObject(string objectName)
    {
        if (!ServiceObjects.TryGetValue(objectName, out var details))
        {
            return false;
        }

        return details.Any(detail => HasInsecureServiceInText(detail));
    }

    private static bool HasInsecureServiceInText(params string[] values)
    {
        return GetInsecureServiceMatches(values).Count > 0;
    }

    private static IReadOnlyList<InsecureMatch> GetInsecureServiceMatches(params string[] values)
    {
        var matches = new List<InsecureMatch>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var value in values)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                continue;
            }

            var tokens = Tokenize(value);
            if (tokens.Length == 0)
            {
                continue;
            }

            for (var i = 0; i < tokens.Length; i++)
            {
                var token = tokens[i];
                if (IsInsecureServiceName(token, out _))
                {
                    AddMatch(matches, seen, InsecureMatchKind.ServiceName, token);
                }

                if (token.Equals("eq", StringComparison.OrdinalIgnoreCase) ||
                    token.Equals("neq", StringComparison.OrdinalIgnoreCase) ||
                    token.Equals("gt", StringComparison.OrdinalIgnoreCase) ||
                    token.Equals("lt", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 1 < tokens.Length)
                    {
                        var nextToken = tokens[i + 1];
                        if (IsInsecureServiceName(nextToken, out _))
                        {
                            AddMatch(matches, seen, InsecureMatchKind.ServiceName, nextToken);
                        }
                        else if (int.TryParse(nextToken, out var port) && IsInsecurePort(port))
                        {
                            AddMatch(matches, seen, InsecureMatchKind.Port, port.ToString(CultureInfo.InvariantCulture));
                        }
                    }
                    continue;
                }

                if (token.Equals("range", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 2 < tokens.Length &&
                        TryParsePortToken(tokens[i + 1], out var startPort) &&
                        TryParsePortToken(tokens[i + 2], out var endPort))
                    {
                        if (startPort > endPort)
                        {
                            (startPort, endPort) = (endPort, startPort);
                        }

                        if (ViolationConfig.InsecurePorts.Any(port => port >= startPort && port <= endPort))
                        {
                            AddMatch(matches, seen, InsecureMatchKind.Port, $"range {startPort}-{endPort}");
                        }
                    }
                }
            }
        }

        return matches;
    }

    private static void AddMatch(List<InsecureMatch> matches, HashSet<string> seen, InsecureMatchKind kind, string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        var key = $"{kind}:{value}";
        if (!seen.Add(key))
        {
            return;
        }

        matches.Add(new InsecureMatch(kind, value));
    }

    private static bool IsInsecureServiceName(string token, out int port)
    {
        return ViolationConfig.InsecureServicePorts.TryGetValue(token, out port);
    }

    private static bool TryParsePortToken(string token, out int port)
    {
        if (int.TryParse(token, out port))
        {
            return true;
        }

        return ViolationConfig.InsecureServicePorts.TryGetValue(token, out port);
    }

    private static bool IsInsecurePort(int port)
    {
        return ViolationConfig.InsecurePorts.Contains(port);
    }

    private static string BuildInsecureServiceTooltip(IReadOnlyList<InsecureMatch> matches)
    {
        if (matches.Count == 0)
        {
            return string.Empty;
        }

        var lines = new List<string>();
        foreach (var match in matches)
        {
            if (match.Kind == InsecureMatchKind.ServiceName)
            {
                if (ViolationConfig.InsecureServicePorts.TryGetValue(match.Value, out var port))
                {
                    lines.Add($"Service: {match.Value} ({port})");
                }
                else
                {
                    lines.Add($"Service: {match.Value}");
                }
                continue;
            }

            if (int.TryParse(match.Value, out var portValue))
            {
                var names = ViolationConfig.InsecureServicePorts
                    .Where(entry => entry.Value == portValue)
                    .Select(entry => entry.Key)
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .ToList();

                if (names.Count > 0)
                {
                    lines.Add($"Port: {portValue} ({string.Join("/", names)})");
                }
                else
                {
                    lines.Add($"Port: {portValue}");
                }
                continue;
            }

            lines.Add($"Port: {match.Value}");
        }

        return $"Insecure:{Environment.NewLine}{string.Join(Environment.NewLine, lines.Distinct())}";
    }

    private static bool IsAnyText(string value)
    {
        return value.Equals("Any", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsCrossZoneText(string sourceInfo, string destinationInfo)
    {
        foreach (var pair in ViolationConfig.CrossZonePairs)
        {
            var prefixA = pair.PrefixA;
            var prefixB = pair.PrefixB;
            if (string.IsNullOrWhiteSpace(prefixA) || string.IsNullOrWhiteSpace(prefixB))
            {
                continue;
            }

            if ((sourceInfo.Contains(prefixA, StringComparison.Ordinal) && destinationInfo.Contains(prefixB, StringComparison.Ordinal)) ||
                (sourceInfo.Contains(prefixB, StringComparison.Ordinal) && destinationInfo.Contains(prefixA, StringComparison.Ordinal)))
            {
                return true;
            }
        }

        return false;
    }

    private static bool IsOverPermissiveText(string value)
    {
        var info = TryParseAddressInfoFromText(value);
        return info is not null && IsOverPermissiveNetwork(info);
    }

    private List<ViolationRule> ViolationRules => _violationRules ??= BuildViolationRules();
    private List<ViolationRule>? _violationRules;

    private List<ViolationRule> BuildViolationRules()
    {
        return new List<ViolationRule>
        {
            new("Any to Any",
                entry => IsAnyAnyViolation(entry),
                (entry, context) => IsAnyAnyViolation(entry) &&
                                    IsAnyText(context.SourceInfo) &&
                                    IsAnyText(context.DestinationInfo)),
            new("Cross-zone",
                entry => IsCrossZoneViolation(entry),
                (entry, context) => IsCrossZoneViolation(entry) &&
                                    IsCrossZoneText(context.SourceInfo, context.DestinationInfo)),
            new("Over-permissive",
                entry => IsOverPermissiveViolation(entry),
                (entry, context) => IsOverPermissiveViolation(entry) &&
                                    IsOverPermissiveText(context.DestinationInfo)),
            new("Insecure service",
                entry => IsInsecureServiceViolation(entry),
                (entry, context) => IsInsecureServiceViolation(entry) &&
                                    HasInsecureServiceInText(context.ProtocolInfo, context.DestinationPortInfo))
        };
    }

    private int AnyAnyViolationCount => CountViolations("Any to Any");
    private int CrossZoneViolationCount => CountViolations("Cross-zone");
    private int OverPermissiveViolationCount => CountViolations("Over-permissive");
    private int InsecureServiceViolationCount => CountViolations("Insecure service");

    private int CountViolations(string name)
    {
        return Entries.Count(entry =>
            ViolationRules.Any(rule => rule.Name == name && rule.AppliesToRule(entry)));
    }

    private bool IsPermit(AclEntry entry)
    {
        return entry.Action.Equals("permit", StringComparison.OrdinalIgnoreCase);
    }

    private bool IsAnyAnyViolation(AclEntry entry)
    {
        if (!IsPermit(entry))
        {
            return false;
        }

        var sources = ExpandAddressInfos(entry.Source);
        var destinations = ExpandAddressInfos(entry.Destination);

        return sources.Any(info => info.IsAny) && destinations.Any(info => info.IsAny);
    }

    private bool IsCrossZoneViolation(AclEntry entry)
    {
        if (!IsPermit(entry))
        {
            return false;
        }

        var sources = ExpandAddressInfos(entry.Source);
        var destinations = ExpandAddressInfos(entry.Destination);

        foreach (var pair in ViolationConfig.CrossZonePairs)
        {
            var crossesForward = sources.Any(source => IsInSubnet(source, pair.SubnetA, pair.PrefixLength)) &&
                                 destinations.Any(destination => IsInSubnet(destination, pair.SubnetB, pair.PrefixLength));
            var crossesReverse = sources.Any(source => IsInSubnet(source, pair.SubnetB, pair.PrefixLength)) &&
                                 destinations.Any(destination => IsInSubnet(destination, pair.SubnetA, pair.PrefixLength));

            if (crossesForward || crossesReverse)
            {
                return true;
            }
        }

        return false;
    }

    private bool IsOverPermissiveViolation(AclEntry entry)
    {
        if (!IsPermit(entry))
        {
            return false;
        }

        var sources = ExpandAddressInfos(entry.Source).ToList();
        var destinations = ExpandAddressInfos(entry.Destination);

        var hasSmallSourceScope = sources.Count > 0 && sources.All(IsSmallSourceScope);
        var destinationNetworks = destinations.Where(IsOverPermissiveNetwork).ToList();

        return hasSmallSourceScope && destinationNetworks.Count > 0;
    }

    private static bool IsOverPermissiveNetwork(AddressInfo info)
    {
        if (!info.IsNetwork || info.PrefixLength is null || info.Address is null)
        {
            return false;
        }

        if (!ViolationConfig.OverPermissiveRootSubnets.Any(root =>
                IsInSubnet(info, root.Subnet, root.PrefixLength)))
        {
            return false;
        }

        return info.PrefixLength <= ViolationConfig.OverPermissiveMaxPrefixLength;
    }

    private static bool IsSmallSourceScope(AddressInfo info)
    {
        if (info.IsHost)
        {
            return true;
        }

        return info.IsNetwork && info.PrefixLength is not null && info.PrefixLength >= ViolationConfig.SmallSourceMinPrefixLength;
    }

    private static AddressInfo? TryParseAddressInfoFromText(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return null;
        }

        var tokens = Tokenize(value);
        for (var i = 0; i < tokens.Length; i++)
        {
            var token = tokens[i];
            if (token.Equals("host", StringComparison.OrdinalIgnoreCase) && i + 1 < tokens.Length)
            {
                return ParseAddressInfo($"host {tokens[i + 1]}");
            }

            if (token.Equals("subnet", StringComparison.OrdinalIgnoreCase) && i + 2 < tokens.Length)
            {
                return ParseAddressInfo($"{tokens[i + 1]} {tokens[i + 2]}");
            }

            if (IPAddress.TryParse(token, out _))
            {
                if (i + 1 < tokens.Length &&
                    (tokens[i + 1].StartsWith("/", StringComparison.OrdinalIgnoreCase) ||
                     IPAddress.TryParse(tokens[i + 1], out _)))
                {
                    return ParseAddressInfo($"{token} {tokens[i + 1]}");
                }
            }
        }

        return null;
    }

    private static AddressInfo ParseAddressInfo(string address)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            return AddressInfo.Unknown();
        }

        if (address.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            return AddressInfo.Any();
        }

        if (address.StartsWith("host ", StringComparison.OrdinalIgnoreCase))
        {
            var hostValue = address.Substring("host ".Length).Trim();
            return IPAddress.TryParse(hostValue, out var ip)
                ? AddressInfo.Host(ip)
                : AddressInfo.Unknown();
        }

        var parts = address.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length >= 2 && IPAddress.TryParse(parts[0], out var networkIp))
        {
            if (parts[1].StartsWith("/", StringComparison.OrdinalIgnoreCase))
            {
                if (int.TryParse(parts[1].TrimStart('/'), out var prefixLength))
                {
                    return AddressInfo.Network(networkIp, prefixLength);
                }
            }
            else if (IPAddress.TryParse(parts[1], out var maskIp))
            {
                var prefixLength = PrefixLengthFromMask(maskIp);
                if (prefixLength is not null)
                {
                    return AddressInfo.Network(networkIp, prefixLength.Value);
                }
            }
        }

        if (parts.Length == 1 && address.Contains('/', StringComparison.Ordinal))
        {
            var slashParts = address.Split('/', StringSplitOptions.RemoveEmptyEntries);
            if (slashParts.Length == 2 &&
                IPAddress.TryParse(slashParts[0], out var cidrIp) &&
                int.TryParse(slashParts[1], out var cidrPrefix))
            {
                return AddressInfo.Network(cidrIp, cidrPrefix);
            }
        }

        return AddressInfo.Unknown();
    }

    private static bool IsInSubnet(AddressInfo info, string subnetIp, int prefixLength)
    {
        if (info.Address is null)
        {
            return false;
        }

        if (!IPAddress.TryParse(subnetIp, out var subnetAddress))
        {
            return false;
        }

        if (info.IsNetwork && info.PrefixLength is not null && info.PrefixLength < prefixLength)
        {
            return false;
        }

        var mask = PrefixLengthToMask(prefixLength);
        return (ToUInt32(info.Address) & mask) == (ToUInt32(subnetAddress) & mask);
    }

    private static uint PrefixLengthToMask(int prefixLength)
    {
        if (prefixLength <= 0)
        {
            return 0u;
        }

        return prefixLength >= 32 ? 0xffffffffu : 0xffffffffu << (32 - prefixLength);
    }

    private static int? PrefixLengthFromMask(IPAddress mask)
    {
        var maskValue = ToUInt32(mask);
        var count = 0;
        var zeroFound = false;

        for (var i = 31; i >= 0; i--)
        {
            var bitSet = (maskValue & (1u << i)) != 0;
            if (bitSet)
            {
                if (zeroFound)
                {
                    return null;
                }

                count++;
            }
            else
            {
                zeroFound = true;
            }
        }

        return count;
    }

    private static uint ToUInt32(IPAddress ip)
    {
        var bytes = ip.GetAddressBytes();
        if (bytes.Length != 4)
        {
            return 0u;
        }

        if (BitConverter.IsLittleEndian)
        {
            Array.Reverse(bytes);
        }

        return BitConverter.ToUInt32(bytes, 0);
    }

    private IEnumerable<AddressInfo> ExpandAddressInfos(string address)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            return Array.Empty<AddressInfo>();
        }

        if (address.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            var groupName = address.Substring("object-group ".Length).Trim();
            return ExpandGroupMembers(groupName, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
        }

        if (address.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            var objectName = address.Substring("object ".Length).Trim();
            return ExpandNetworkObjectEntries(objectName);
        }

        return new[] { ParseAddressInfo(address) };
    }

    private IEnumerable<AddressInfo> ExpandGroupMembers(string groupName, HashSet<string> visitedGroups)
    {
        if (string.IsNullOrWhiteSpace(groupName) || !visitedGroups.Add(groupName))
        {
            return Array.Empty<AddressInfo>();
        }

        if (!NetworkObjectGroups.TryGetValue(groupName, out var members))
        {
            return Array.Empty<AddressInfo>();
        }

        var results = new List<AddressInfo>();

        foreach (var member in members)
        {
            if (member.StartsWith("group-object ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("group-object ".Length).Trim();
                results.AddRange(ExpandGroupMembers(nestedName, visitedGroups));
                continue;
            }

            if (member.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
            {
                var nestedName = member.Substring("object-group ".Length).Trim();
                results.AddRange(ExpandGroupMembers(nestedName, visitedGroups));
                continue;
            }

            if (member.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
            {
                var objectName = member.Substring("object ".Length).Trim();
                results.AddRange(ExpandNetworkObjectEntries(objectName));
                continue;
            }

            var info = ParseAddressInfo(member);
            results.Add(info);
        }

        return results;
    }

    private IEnumerable<AddressInfo> ExpandNetworkObjectEntries(string objectName)
    {
        if (!NetworkObjects.TryGetValue(objectName, out var details))
        {
            return Array.Empty<AddressInfo>();
        }

        var results = new List<AddressInfo>();

        foreach (var detail in details)
        {
            if (detail.StartsWith("host ", StringComparison.OrdinalIgnoreCase))
            {
                results.Add(ParseAddressInfo(detail));
                continue;
            }

            if (detail.StartsWith("subnet ", StringComparison.OrdinalIgnoreCase))
            {
                var parts = detail.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 3)
                {
                    results.Add(ParseAddressInfo($"{parts[1]} {parts[2]}"));
                }
                continue;
            }

            if (detail.StartsWith("range ", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (detail.StartsWith("fqdn ", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }
        }

        return results;
    }

    private sealed record AclEntry(
        int LineNumber,
        int Occurrence,
        string Raw,
        string AclName,
        string Interface,
        string Action,
        string Protocol,
        string Source,
        string SourcePort,
        string Destination,
        string DestinationPort,
        string Options,
        string Remark,
        bool Log);

    private sealed record AclDetailRow(
        string ProtocolInfo,
        string ProtocolPrefix,
        string SourceInfo,
        string SourcePrefix,
        string DestinationInfo,
        string DestinationPrefix,
        string DestinationPortInfo,
        string DestinationPortPrefix,
        IReadOnlyList<string> Violations,
        string SourceCrossZonePairs,
        string DestinationCrossZonePairs);

    private sealed record DetailRowContext(
        string ProtocolInfo,
        string SourceInfo,
        string DestinationInfo,
        string DestinationPortInfo);

    private sealed record DetailNode(string Text, int Indent);

    private sealed record ViolationRule(
        string Name,
        Func<AclEntry, bool> AppliesToRule,
        Func<AclEntry, DetailRowContext, bool>? AppliesToRow);

    private enum InsecureMatchKind
    {
        ServiceName,
        Port
    }

    private sealed record InsecureMatch(InsecureMatchKind Kind, string Value);

    private sealed class CrossZoneRule
    {
        public CrossZoneRule(string subnetA, string subnetB, int prefixLength)
        {
            SubnetA = subnetA;
            SubnetB = subnetB;
            PrefixLength = prefixLength;
            PrefixA = BuildPrefixFromSubnet(subnetA, prefixLength);
            PrefixB = BuildPrefixFromSubnet(subnetB, prefixLength);
        }

        public string SubnetA { get; }
        public string SubnetB { get; }
        public int PrefixLength { get; }
        public string PrefixA { get; }
        public string PrefixB { get; }

        private static string BuildPrefixFromSubnet(string subnet, int prefixLength)
        {
            if (prefixLength <= 0 || prefixLength > 32 || prefixLength % 8 != 0)
            {
                return string.Empty;
            }

            if (!IPAddress.TryParse(subnet, out var ip))
            {
                return string.Empty;
            }

            var bytes = ip.GetAddressBytes();
            if (bytes.Length != 4)
            {
                return string.Empty;
            }

            var octets = prefixLength / 8;
            var builder = new StringBuilder();
            for (var i = 0; i < octets; i++)
            {
                if (i > 0)
                {
                    builder.Append('.');
                }
                builder.Append(bytes[i]);
            }

            if (octets < 4)
            {
                builder.Append('.');
            }

            return builder.ToString();
        }
    }

    private sealed record SubnetRule(string Subnet, int PrefixLength);

    private sealed class ViolationSettings
    {
        public ViolationSettings(
            IReadOnlyList<CrossZoneRule> crossZonePairs,
            IReadOnlyList<SubnetRule> overPermissiveRootSubnets,
            int overPermissiveMaxPrefixLength,
            int smallSourceMinPrefixLength,
            IReadOnlyDictionary<string, int> insecureServicePorts)
        {
            CrossZonePairs = crossZonePairs;
            OverPermissiveRootSubnets = overPermissiveRootSubnets;
            OverPermissiveMaxPrefixLength = overPermissiveMaxPrefixLength;
            SmallSourceMinPrefixLength = smallSourceMinPrefixLength;
            InsecureServicePorts = insecureServicePorts;
            InsecurePorts = new HashSet<int>(insecureServicePorts.Values);
        }

        public IReadOnlyList<CrossZoneRule> CrossZonePairs { get; }
        public IReadOnlyList<SubnetRule> OverPermissiveRootSubnets { get; }
        public int OverPermissiveMaxPrefixLength { get; }
        public int SmallSourceMinPrefixLength { get; }
        public IReadOnlyDictionary<string, int> InsecureServicePorts { get; }
        public HashSet<int> InsecurePorts { get; }
    }

    private sealed record LogFileEntry(string DisplayName, IBrowserFile File, string RelativePath);

    private sealed class LogTreeNode
    {
        public LogTreeNode(string name, bool isFolder, LogFileEntry? fileEntry)
        {
            Name = name;
            IsFolder = isFolder;
            FileEntry = fileEntry;
            IsExpanded = false;
        }

        public string Name { get; }
        public bool IsFolder { get; }
        public LogFileEntry? FileEntry { get; }
        public bool IsExpanded { get; set; }
    }

    private sealed class AddressInfo
    {
        private AddressInfo(bool isAny, bool isHost, bool isNetwork, IPAddress? address, int? prefixLength)
        {
            IsAny = isAny;
            IsHost = isHost;
            IsNetwork = isNetwork;
            Address = address;
            PrefixLength = prefixLength;
        }

        public bool IsAny { get; }
        public bool IsHost { get; }
        public bool IsNetwork { get; }
        public IPAddress? Address { get; }
        public int? PrefixLength { get; }

        public static AddressInfo Any() => new(true, false, false, null, null);
        public static AddressInfo Host(IPAddress address) => new(false, true, false, address, null);
        public static AddressInfo Network(IPAddress address, int prefixLength) => new(false, false, true, address, prefixLength);
        public static AddressInfo Unknown() => new(false, false, false, null, null);
    }
}

<style>


    .acl-drop-zone {
        position: relative;
        border: 2px rgba(0, 0, 0, 0.25);
        border-radius: 16px;
        padding: 28px;
        min-height: 190px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(var(--custom-rotation), var(--mud-palette-primary), var(--mud-palette-primary-darken));
        --custom-rotation: 135deg;
        transition: --custom-rotation 0.3s ease, border 0.1s ease;
    }

    .acl-drop-zone:hover {
        --custom-rotation: 180deg;
        border: 2px inset var(--mud-palette-primary);
    }

    .acl-drop-input {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
    }

    .acl-drop-content {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
    }

    .acl-drop-icon {
        font-size: 34px;
        opacity: 0.7;
    }

    .acl-drop-hint {
        color: rgba(255, 255, 255, 0.85);
    }

    .acl-file-panel {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 12px;
        height: 100%;
    }

    .acl-file-tree {
        max-height: 320px;
        overflow: auto;
    }

    .acl-file-active {
        background-color: rgba(33, 150, 243, 0.12);
        border-radius: 8px;
    }

    .acl-tree-item {
        display: flex;
        align-items: center;
        gap: 6px;
        padding-left: calc(var(--depth, 0) * 16px);
        color: var(--mud-palette-text-primary);
    }

    .acl-tree-folder {
        opacity: 0.85;
    }

    .acl-tree-row {
        cursor: pointer;
    }

    .acl-tree-text {
        font-size: 0.875rem;
    }

    .acl-violation-summary {
        background: rgba(255, 193, 7, 0.08);
        border: 1px solid rgba(255, 193, 7, 0.18);
        border-radius: 10px;
        padding: 8px 10px;
    }

    .acl-row-deny {
        background-color: rgba(244, 67, 54, 0.08);
    }

    .acl-row-remark {
        background-color: rgba(158, 158, 158, 0.08);
    }

    .acl-row-selected {
        outline: 2px solid rgba(33, 150, 243, 0.35);
        outline-offset: -2px;
    }

    .acl-detail-scroll {
        flex: 1 1 auto;
        min-height: 0;
        position: relative;
    }

    .acl-panel {
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .acl-panel-scroll {
        flex: 1 1 0;
        min-height: 0;
    }

    .acl-right-stack {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
    }

    .acl-right-column {
        min-height: 0;
        --acl-table-height: clamp(220px, 32vh, 520px);
    }

    @@media (min-width: 960px) {
        .acl-right-column {
            height: calc(100vh - 160px);
        }
    }

    .acl-detail-cell {
        white-space: pre-wrap;
        line-height: 0.9;
    }

    .acl-detail-table {
        background-color: transparent;
    }

    .acl-detail-table .mud-table-cell {
        padding: 0 6px;
        background-color: transparent;
    }

    .acl-detail-table .mud-table-row {
        line-height: 0.9;
        background-color: transparent;
    }

    .acl-detail-table .mud-chip {
        margin: 0;
    }

    .acl-detail-table .mud-chip-content {
        padding: 0 6px;
    }

    .acl-detail-warning {
        display: inline-flex;
        align-items: center;
        margin-left: 6px;
        vertical-align: middle;
        cursor: pointer;
    }

    .acl-cross-zone-svg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .acl-detail-scroll .mud-table {
        position: relative;
        z-index: 2;
    }

    .acl-cross-zone-source-marker,
    .acl-cross-zone-dest-marker {
        display: inline-block;
        width: 0;
        height: 0;
        vertical-align: middle;
    }

    .acl-cross-zone-source-marker[data-cross-zone-pairs],
    .acl-cross-zone-dest-marker[data-cross-zone-pairs] {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: var(--mud-palette-warning);
        opacity: 0.7;
        cursor: pointer;
    }

    .acl-cross-zone-source-marker[data-cross-zone-pairs] {
        margin-left: 4px;
    }

    .acl-cross-zone-dest-marker[data-cross-zone-pairs] {
        margin-right: -14px;
        position: relative;
        background: transparent;
        opacity: 1;
        cursor: pointer;
        z-index: 3;
    }

    .acl-cross-zone-dest-marker-root[data-cross-zone-pairs] {
        margin-right: -14px;
        width: 14px;
        height: 14px;
    }

    .acl-cross-zone-source-marker[data-cross-zone-pairs]:hover,
    .acl-cross-zone-dest-marker[data-cross-zone-pairs]:hover {
        opacity: 0.95;
    }

    .acl-tree-prefix {
        margin-right: 4px;
        font-size: 1.25em;
        line-height: 0.9;
        display: inline-block;
        margin-top: -1px;
        margin-bottom: -1px;
    }

    .acl-tree-prefix {
        color: currentColor;
        font-family: "Courier New", monospace;
        white-space: pre;
    }

    .acl-rules-header {
        justify-content: space-between;
        gap: 12px;
        width: 100%;
    }

    .acl-rules-title {
        color: var(--mud-palette-primary);
        letter-spacing: 0.3px;
        line-height: 1.1;
    }
</style>
