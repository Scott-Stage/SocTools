import os
import re
import string
import math # For infinity
import textwrap # Import for word wrapping

# --- Configuration ---
DEBUG = False # Set to True to see detailed comparison steps
JACCARD_PROMOTION_THRESHOLD = 0.5  # Threshold (0.0 to 1.0) for promoting partial to full (<= Threshold)
JACCARD_NO_MATCH_THRESHOLD = 0.85 # Threshold (0.0 to 1.0) for classifying weak partials as 'Not Found' (>= Threshold)

# --- Manual Whitelist (DB Entries) ---
# If a partial match involves any of these *exact DB entries*, promote to Full Match.
MANUAL_WHITELIST = [
    "Example Whitelisted DB Entry v1",
    "Another Critical DB Software Name",
]
MANUAL_WHITELIST_SET = set(MANUAL_WHITELIST)

# --- Manual Blacklist (Your Software Entries) ---
# Any *exact entry* from your software list found here will be forced to 'Not Found'.
MANUAL_BLACKLIST = [
    "Known Problematic Software Entry",
    "Ignore This Specific Version",
]
MANUAL_BLACKLIST_SET = set(MANUAL_BLACKLIST)

# --- Stop Words ---
# These words will be removed during normalization *before* comparison.
# Add words carefully, as removing too many might cause incorrect matches.
STOP_WORDS = [
    'a', 'an', 'and', 'the', 'of', 'in', 'on', 'at', 'to', 'for', 'with',
    'server', 'client', 'manager', 'utility', 'agent', 'service',
    'enterprise', 'professional', 'edition', 'version',
    'v', 'r', # Common short version indicators - use with caution
    # Add more common/non-discriminating words here
]
STOP_WORDS_SET = set(STOP_WORDS)


# --- Column Widths for Output Table ---
WIDTH_MY_SW = 40
WIDTH_MATCHED_COL = 40
WIDTH_REASON = 50

def read_software_list(filepath):
    """Reads a software list from a file, one item per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

def normalize_name(name):
    """
    Normalizes software name: lowercase, strip, remove punctuation,
    remove STOP WORDS, remove duplicates, rejoin sorted unique words.
    """
    if not name: return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator)
    name = name.lower().strip()
    name = re.sub(r'\s+', ' ', name)
    # Split into tokens and remove stop words
    tokens = [token for token in name.split() if token not in STOP_WORDS_SET]
    # Get unique, sorted remaining tokens
    unique_sorted_tokens = sorted(list(set(filter(None, tokens)))) # Filter None just in case
    if not unique_sorted_tokens:
        # If all words were stop words, return special marker or empty?
        # Returning empty means it won't match anything, which seems reasonable.
        return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    """ Calculates Jaccard distance: len(symm_diff) / len(union) """
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0
    return len(sym_diff) / len(union)


def compare_lists(my_software_list, db_software_list):
    """
    Compares lists including blacklist, stop words, whitelist, and thresholds.
    """
    if my_software_list is None or db_software_list is None: return None

    # --- Prepare Database Data ---
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries (applying stop words)...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item) # Stop words applied here
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item) # Store original for whitelist check
    if DEBUG: print(f"Normalized DB forms: {list(db_token_sets.keys())}")
    if DEBUG: print(f"Manual Whitelist Set: {MANUAL_WHITELIST_SET}")
    if DEBUG: print(f"Manual Blacklist Set: {MANUAL_BLACKLIST_SET}")
    if DEBUG: print(f"Stop Words Set: {STOP_WORDS_SET}")

    # --- Initialize Results Storage ---
    comparison_results = []
    processed_my_software_originals = set()

    # --- Compare Each Item in My List ---
    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        result_entry = {
            'my_sw_orig': my_sw_orig, 'status': 'Not Found',
            'matched_db_orig': None, 'reason': None, 'jaccard': None,
            'all_partial_db_matches': [], 'nearest_candidate_orig': None,
            'nearest_candidate_jaccard': 1.1
        }
        if my_sw_orig in processed_my_software_originals: continue
        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}): '{my_sw_orig}' ---")

        # --- Check Blacklist FIRST ---
        if my_sw_orig in MANUAL_BLACKLIST_SET:
            if DEBUG: print(f"  Item is on Manual Blacklist. Classifying as Not Found.")
            result_entry['status'] = 'Not Found'
            result_entry['reason'] = "Manual Blacklist"
            comparison_results.append(result_entry)
            processed_my_software_originals.add(my_sw_orig)
            continue # Skip all other processing for this item

        # --- Normalize (including stop words) ---
        my_sw_norm = normalize_name(my_sw_orig)
        if not my_sw_norm:
            if DEBUG: print(f"  Normalized to empty (after stop words), classifying as Not Found.")
            result_entry['reason'] = "Input empty after stop words"
            comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
             if DEBUG: print(f"  Token set empty, classifying as Not Found.")
             result_entry['reason'] = "Input has no valid tokens"
             comparison_results.append(result_entry); processed_my_software_originals.add(my_sw_orig); continue
        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        # --- Comparison Logic (largely unchanged, but uses stop-word-filtered tokens) ---
        found_direct_full_match = False
        potential_partial_details = []
        min_overall_jaccard = 1.1
        best_overall_candidate_norm = None
        db_check_counter = 0

        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1
            if not db_tokens: continue
            if DEBUG: print(f"  Checking against DB entry {db_check_counter}: '{db_norm}' | Tokens: {db_tokens}")

            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)

            if jaccard_dist < min_overall_jaccard:
                 min_overall_jaccard = jaccard_dist; best_overall_candidate_norm = db_norm

            if DEBUG: print(f"    Symm Diff: {symmetric_difference} (Size: {sym_diff_len}) | Jaccard Dist: {jaccard_dist:.4f}")

            # Check for Direct Full Match (Priority 1)
            if sym_diff_len <= 1:
                if DEBUG: print(f"    --> Direct Full Match found (Symm Diff <= 1).")
                result_entry['status'] = 'Full Match'
                result_entry['matched_db_orig'] = db_normalized_map[db_norm][0]
                result_entry['reason'] = f"Symmetric Diff <= 1 (Size={sym_diff_len})"
                result_entry['jaccard'] = jaccard_dist
                found_direct_full_match = True; break

            # Check for Potential Partial Criteria
            criterion_A = (sym_diff_len == 2)
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens
            criterion_B = (is_proper_subset_my_in_db and len(my_sw_tokens) >= 2) or \
                          (is_proper_subset_db_in_my and len(db_tokens) >= 2)
            partial_reason = None
            if criterion_A: partial_reason = "Symmetric Diff == 2"
            if criterion_B: partial_reason = "Subset >= 2 tokens"

            if partial_reason:
                 potential_partial_details.append({
                     'jaccard': jaccard_dist, 'db_norm': db_norm, 'reason': partial_reason
                 })
                 if DEBUG: print(f"    --> Recording potential Partial Match details (Reason: {partial_reason}, Jaccard: {jaccard_dist:.4f}, DB Norm: {db_norm}).")
            elif DEBUG: print(f"    --> No Full or Potential Partial match criteria met.")


        # --- Final Classification Logic ---
        if not found_direct_full_match:
            if potential_partial_details:
                best_potential = min(potential_partial_details, key=lambda x: x['jaccard'])
                min_partial_jaccard = best_potential['jaccard']
                best_partial_reason = best_potential['reason']
                best_partial_db_norm = best_potential['db_norm']
                all_partial_db_origs = set()
                for detail in potential_partial_details: all_partial_db_origs.update(db_normalized_map[detail['db_norm']])
                result_entry['all_partial_db_matches'] = sorted(list(all_partial_db_origs))

                is_whitelisted_partial = any(db_orig in MANUAL_WHITELIST_SET for db_orig in all_partial_db_origs)
                if DEBUG: print(f"  Potential partial matches found. Min Jaccard Distance: {min_partial_jaccard:.4f}. Whitelisted involved: {is_whitelisted_partial}")

                if is_whitelisted_partial: # Whitelist promotion takes priority
                    result_entry['status'] = 'Full Match'
                    result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"Manual Whitelist ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Full Match (Manual Whitelist)")
                elif min_partial_jaccard >= JACCARD_NO_MATCH_THRESHOLD: # Check No Match threshold next
                    result_entry['status'] = 'Not Found'
                    result_entry['reason'] = f"Weak Partial (Min Jaccard={min_partial_jaccard:.2f} >= {JACCARD_NO_MATCH_THRESHOLD:.2f})"
                    if DEBUG: print(f"  FINAL Classification: Not Found (Weak Partial)")
                elif min_partial_jaccard <= JACCARD_PROMOTION_THRESHOLD: # Check Promotion threshold
                    result_entry['status'] = 'Full Match'
                    result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"Promoted ({best_partial_reason}, Jaccard={min_partial_jaccard:.2f})"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Full Match (Promoted)")
                else: # Otherwise, it's a Partial Match
                    result_entry['status'] = 'Partial Match'
                    result_entry['matched_db_orig'] = db_normalized_map[best_partial_db_norm][0]
                    result_entry['reason'] = f"{best_partial_reason}, Jaccard={min_partial_jaccard:.2f}"
                    result_entry['jaccard'] = min_partial_jaccard
                    if DEBUG: print(f"  FINAL Classification: Partial Match")
            else: # No direct match, no potential partials
                result_entry['status'] = 'Not Found'
                if DEBUG: print(f"  FINAL Classification: Not Found (No criteria met)")
        elif DEBUG: print(f"  FINAL Classification: Full Match (Direct)")

        # Set nearest candidate info if classified as Not Found
        if result_entry['status'] == 'Not Found':
             if best_overall_candidate_norm:
                  result_entry['nearest_candidate_orig'] = db_normalized_map[best_overall_candidate_norm][0]
                  result_entry['nearest_candidate_jaccard'] = min_overall_jaccard
                  current_reason = result_entry['reason']
                  # Don't overwrite blacklist or empty-after-stopwords reason
                  if current_reason not in ["Manual Blacklist", "Input empty after stop words", "Input has no valid tokens"]:
                       reason_suffix = f"Nearest Jaccard={min_overall_jaccard:.2f}"
                       # Append or set reason based on weak partial check
                       if current_reason and "Weak Partial" in current_reason:
                            result_entry['reason'] = f"{current_reason} (Nearest Jaccard={min_overall_jaccard:.2f})"
                       else:
                            result_entry['reason'] = reason_suffix
             elif result_entry['reason'] is None:
                  result_entry['reason'] = "No DB entries to compare"

        comparison_results.append(result_entry)
        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return comparison_results


def write_results_table(output_file, comparison_results):
    """Writes the categorized results to a file in table format with word wrap."""
    if comparison_results is None:
        print("Skipping writing results due to previous errors.")
        return

    full_matches = sorted([r for r in comparison_results if r['status'] == 'Full Match'], key=lambda x: x['my_sw_orig'])
    partial_matches = sorted([r for r in comparison_results if r['status'] == 'Partial Match'], key=lambda x: x['my_sw_orig'])
    not_found = sorted([r for r in comparison_results if r['status'] == 'Not Found'], key=lambda x: x['my_sw_orig'])

    def get_wrapped_lines(text, width, default="N/A"):
        if text is None: text = default
        text_str = str(text)
        return textwrap.wrap(text_str, width=width, initial_indent="", subsequent_indent="", drop_whitespace=True) or [default]

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("Software Comparison Results\n")
            f.write("=" * (WIDTH_MY_SW + WIDTH_MATCHED_COL + WIDTH_REASON + 6) + "\n\n")

            # --- Full Matches Table ---
            f.write("=== Full Matches ===\n")
            f.write(f"    (Symm Diff <= 1 OR Whitelisted Partial OR Promoted Partial [Jaccard <= {JACCARD_PROMOTION_THRESHOLD:.2f}])\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Matched DB Entry':<{WIDTH_MATCHED_COL}} | {'Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if full_matches:
                for item in full_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matched_db_lines = get_wrapped_lines(item['matched_db_orig'], WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matched_db_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matched_part = matched_db_lines[i] if i < len(matched_db_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matched_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- Partial Matches Table ---
            f.write("=== Partial Matches ===\n")
            f.write(f"    (Potential Partial AND {JACCARD_PROMOTION_THRESHOLD:.2f} < Jaccard < {JACCARD_NO_MATCH_THRESHOLD:.2f} AND Not Whitelisted)\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Potential DB Matches':<{WIDTH_MATCHED_COL}} | {'Best Match Reason':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if partial_matches:
                for item in partial_matches:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    matches_str = (', '.join(item['all_partial_db_matches']) if item['all_partial_db_matches'] else "N/A")
                    matches_lines = get_wrapped_lines(matches_str, WIDTH_MATCHED_COL)
                    reason_lines = get_wrapped_lines(item['reason'], WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(matches_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        matches_part = matches_lines[i] if i < len(matches_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {matches_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- No Matches Table ---
            f.write("=== No Matches Found ===\n")
            f.write(f"    (Manual Blacklist OR Not Full/Partial OR Weak Partial [Jaccard >= {JACCARD_NO_MATCH_THRESHOLD:.2f}])\n")
            header = f"{'Your Software':<{WIDTH_MY_SW}} | {'Nearest DB Candidate':<{WIDTH_MATCHED_COL}} | {'Reason / Nearest':<{WIDTH_REASON}}"
            f.write(header + "\n")
            f.write("-" * len(header) + "\n")
            if not_found:
                for item in not_found:
                    my_sw_lines = get_wrapped_lines(item['my_sw_orig'], WIDTH_MY_SW)
                    nearest_lines = get_wrapped_lines(item['nearest_candidate_orig'], WIDTH_MATCHED_COL, default="None")
                    reason_str = str(item.get('reason', "N/A"))
                    reason_lines = get_wrapped_lines(reason_str, WIDTH_REASON)
                    max_lines = max(len(my_sw_lines), len(nearest_lines), len(reason_lines))
                    for i in range(max_lines):
                        my_sw_part = my_sw_lines[i] if i < len(my_sw_lines) else ""
                        nearest_part = nearest_lines[i] if i < len(nearest_lines) else ""
                        reason_part = reason_lines[i] if i < len(reason_lines) else ""
                        f.write(f"{my_sw_part:<{WIDTH_MY_SW}} | {nearest_part:<{WIDTH_MATCHED_COL}} | {reason_part:<{WIDTH_REASON}}\n")
            else:
                f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")

    except Exception as e:
        print(f"Error writing results table to file {output_file}: {e}")


# --- Main Execution ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results_table.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print(f"Comparing lists (Jaccard Promo Thresh: {JACCARD_PROMOTION_THRESHOLD}, No Match Thresh: {JACCARD_NO_MATCH_THRESHOLD})...")
        detailed_results = compare_lists(my_list, db_list)
        write_results_table(output_result_file, detailed_results)
    else:
        print("Comparison cancelled due to errors reading input files.")