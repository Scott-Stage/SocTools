    // Level 3: The lowest level (The specific match found)
    public class DetectedComponent
    {
        public string MatchedName { get; set; } = string.Empty; // e.g., "UniversalForwarder"
        public string Version { get; set; } = string.Empty;     // e.g., "9.4.4.0"
        public string KeywordUsed { get; set; } = string.Empty; // e.g., "UniversalForwarder"
    }

    // Level 1: The high-level Wrapper (e.g., "Splunk")
    public class ProductWrapper
    {
        public string FamilyName { get; set; } = string.Empty; 
        public bool Installed { get; set; } = false;

        // This property now holds the grouped list of components found for this family
        public List<DetectedComponent> Components { get; set; } = new List<DetectedComponent>();

        // Helper to get a clean summary string for the UI
        public string VersionSummary
        {
            get 
            {
                if (!Installed || !Components.Any()) return "N/A";
                // Returns unique versions found, e.g., "9.4.4.0" or "9.4.4.0, 8.2.1"
                return string.Join(", ", Components.Select(c => c.Version).Distinct());
            }
        }
    }

    // Configuration object (Unchanged)
    public class ProductDefinition
    {
        public string FamilyName { get; set; }
        public List<string> MatchKeywords { get; set; }

        public ProductDefinition(string name, params string[] keywords)
        {
            FamilyName = name;
            MatchKeywords = new List<string>(keywords);
        }
    }
    public static class SoftwareParser
    {
        public static List<ProductWrapper> AnalyzeSoftware(string rawInput, List<ProductDefinition> definitions)
        {
            var results = new List<ProductWrapper>();

            // 1. Parse Raw Text into a Flat List (Unchanged)
            var allSoftware = new List<(string Name, string Version)>();

            if (!string.IsNullOrWhiteSpace(rawInput))
            {
                string pattern = @"(?:\]\s*|^)(?<name>[^\[]+?)\s*\[version\s+(?<ver>[^\]]+)\]";
                var matches = Regex.Matches(rawInput, pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);

                foreach (Match match in matches)
                {
                    allSoftware.Add((
                        Name: match.Groups["name"].Value.Trim(),
                        Version: match.Groups["ver"].Value.Trim()
                    ));
                }
            }

            // 2. Group into Wrappers
            foreach (var def in definitions)
            {
                var wrapper = new ProductWrapper
                {
                    FamilyName = def.FamilyName,
                    Components = new List<DetectedComponent>()
                };

                // Check against all raw software found
                foreach (var sw in allSoftware)
                {
                    var matchedKeyword = def.MatchKeywords.FirstOrDefault(k => 
                        sw.Name.Contains(k, StringComparison.OrdinalIgnoreCase));

                    if (matchedKeyword != null)
                    {
                        // Add the component directly to the wrapper
                        wrapper.Components.Add(new DetectedComponent
                        {
                            MatchedName = sw.Name,
                            Version = sw.Version,
                            KeywordUsed = matchedKeyword
                        });
                    }
                }

                wrapper.Installed = wrapper.Components.Any();
                results.Add(wrapper);
            }

            return results;
        }
    }