// MicrosoftGraphApiService.cs
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.Http;

public interface ISecretProvider
{
    string? Get(string section, string key);
}

public sealed class MicrosoftGraphApiService
{
    private readonly IHttpClientFactory _httpFactory;
    private readonly IHttpContextAccessor _http;
    private readonly ISecretProvider _secrets;

    // Session keys
    private const string SessState        = "GraphAuth.State";
    private const string SessCodeVerifier = "GraphAuth.CodeVerifier";
    private const string SessAccessToken  = "GraphAuth.AccessToken";
    private const string SessRefreshToken = "GraphAuth.RefreshToken";
    private const string SessExpiresAt    = "GraphAuth.ExpiresAtUtc";

    public MicrosoftGraphApiService(IHttpClientFactory httpFactory, IHttpContextAccessor http, ISecretProvider secrets)
    {
        _httpFactory = httpFactory;
        _http = http;
        _secrets = secrets;
    }

    // ---- Public entry points ------------------------------------------------

    /// <summary>
    /// Returns the full Azure authorize URL. Call this on button-click and NavigateTo it.
    /// </summary>
    public string BuildAuthorizeUrl(string? username, IEnumerable<string> scopes)
    {
        var tenantId     = Need("AzureAd","TenantId");
        var clientId     = Need("AzureAd","ClientId");
        var redirectUri  = GetCallbackAbsoluteUrl(); // e.g. https://localhost:7196/graph/callback

        // PKCE
        var codeVerifier  = CreateCodeVerifier();
        var codeChallenge = CreateCodeChallenge(codeVerifier);

        // CSRF state
        var state = Convert.ToBase64String(RandomNumberGenerator.GetBytes(32));

        var scope = string.Join(' ', scopes);

        // Persist state + code_verifier in session for the round-trip
        var sess = _http.HttpContext!.Session;
        sess.SetString(SessState, state);
        sess.SetString(SessCodeVerifier, codeVerifier);

        // Compose authorize URL
        var q = new Dictionary<string,string?>
        {
            ["client_id"] = clientId,
            ["response_type"] = "code",
            ["redirect_uri"] = redirectUri,
            ["response_mode"] = "query",
            ["scope"] = scope,
            ["code_challenge"] = codeChallenge,
            ["code_challenge_method"] = "S256",
            ["state"] = state,
            // Force a fresh login & hint the username
            ["prompt"] = "login",
            ["login_hint"] = string.IsNullOrWhiteSpace(username) ? null : username
        };

        var authUrl = $"https://login.microsoftonline.com/{Uri.EscapeDataString(tenantId)}/oauth2/v2.0/authorize{ToQueryString(q)}";
        return authUrl;
    }

    /// <summary>
    /// Handle the /graph/callback hit from Azure. Call this from your callback page with ?code=&state=
    /// </summary>
    public async Task<bool> CompleteAuthorizationAsync(string code, string state, CancellationToken ct = default)
    {
        var tenantId     = Need("AzureAd","TenantId");
        var clientId     = Need("AzureAd","ClientId");
        var clientSecret = Need("AzureAd","ClientSecret");
        var redirectUri  = GetCallbackAbsoluteUrl();

        // Validate state
        var sess = _http.HttpContext!.Session;
        var expectedState = sess.GetString(SessState);
        if (string.IsNullOrEmpty(expectedState) || !string.Equals(expectedState, state, StringComparison.Ordinal))
            throw new InvalidOperationException("Invalid state");

        var codeVerifier = sess.GetString(SessCodeVerifier) ?? throw new InvalidOperationException("Missing code_verifier");

        // Exchange code for tokens
        var tokenUrl = $"https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token";
        var form = new Dictionary<string,string>
        {
            ["grant_type"] = "authorization_code",
            ["client_id"] = clientId,
            ["client_secret"] = clientSecret,
            ["code"] = code,
            ["redirect_uri"] = redirectUri,
            ["code_verifier"] = codeVerifier
        };

        var http = _httpFactory.CreateClient(); // transient client just for token call
        using var resp = await http.PostAsync(tokenUrl, new FormUrlEncodedContent(form), ct);
        var json = await resp.Content.ReadAsStringAsync(ct);
        if (!resp.IsSuccessStatusCode)
            throw new InvalidOperationException($"Token exchange failed: {(int)resp.StatusCode} {resp.ReasonPhrase}\n{json}");

        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        var accessToken  = root.GetProperty("access_token").GetString()!;
        var refreshToken = root.TryGetProperty("refresh_token", out var rt) ? rt.GetString() : null;
        var expiresIn    = root.TryGetProperty("expires_in", out var ei) ? ei.GetInt32() : 3600;
        var expiresAtUtc = DateTimeOffset.UtcNow.AddSeconds(expiresIn - 60); // safety buffer

        sess.SetString(SessAccessToken, accessToken);
        if (!string.IsNullOrEmpty(refreshToken)) sess.SetString(SessRefreshToken, refreshToken);
        sess.SetString(SessExpiresAt, expiresAtUtc.ToUnixTimeSeconds().ToString());

        // cleanup one-time items
        sess.Remove(SessState);
        sess.Remove(SessCodeVerifier);

        return true;
    }

    /// <summary>GET /me using the stored token. Requires User.Read delegated scope granted at sign-in.</summary>
    public async Task<JsonElement?> GetMeAsync(CancellationToken ct = default)
    {
        var http = await CreateAuthedGraphClientAsync(ct);
        using var resp = await http.GetAsync("me?$select=id,displayName,userPrincipalName,mail", ct);
        var json = await resp.Content.ReadAsStringAsync(ct);
        resp.EnsureSuccessStatusCode();
        return JsonDocument.Parse(json).RootElement;
    }

    /// <summary>List eDiscovery cases. Requires eDiscovery.Read.All and proper Purview role.</summary>
    public async Task<JsonElement?> ListEdiscoveryCasesAsync(int top = 20, CancellationToken ct = default)
    {
        var http = await CreateAuthedGraphClientAsync(ct);
        using var resp = await http.GetAsync($"security/cases/ediscoveryCases?$top={top}", ct);
        var json = await resp.Content.ReadAsStringAsync(ct);
        resp.EnsureSuccessStatusCode();
        return JsonDocument.Parse(json).RootElement;
    }

    /// <summary>Disconnect: clears tokens from session.</summary>
    public void Disconnect()
    {
        var sess = _http.HttpContext!.Session;
        sess.Remove(SessAccessToken);
        sess.Remove(SessRefreshToken);
        sess.Remove(SessExpiresAt);
    }

    // ---- Internals ----------------------------------------------------------

    private async Task<HttpClient> CreateAuthedGraphClientAsync(CancellationToken ct)
    {
        var token = await GetValidAccessTokenAsync(ct);
        var http = _httpFactory.CreateClient("GraphApi");
        http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
        return http;
    }

    private async Task<string> GetValidAccessTokenAsync(CancellationToken ct)
    {
        var sess = _http.HttpContext!.Session;
        var token = sess.GetString(SessAccessToken);
        var expStr = sess.GetString(SessExpiresAt);

        if (!string.IsNullOrEmpty(token) && long.TryParse(expStr, out var expUnix) &&
            DateTimeOffset.UtcNow < DateTimeOffset.FromUnixTimeSeconds(expUnix))
        {
            return token;
        }

        // try refresh
        var refresh = sess.GetString(SessRefreshToken);
        if (!string.IsNullOrEmpty(refresh))
        {
            var tenantId     = Need("AzureAd","TenantId");
            var clientId     = Need("AzureAd","ClientId");
            var clientSecret = Need("AzureAd","ClientSecret");
            var tokenUrl     = $"https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token";

            var form = new Dictionary<string,string>
            {
                ["grant_type"] = "refresh_token",
                ["client_id"] = clientId,
                ["client_secret"] = clientSecret,
                ["refresh_token"] = refresh
            };

            var http = _httpFactory.CreateClient();
            using var resp = await http.PostAsync(tokenUrl, new FormUrlEncodedContent(form), ct);
            var json = await resp.Content.ReadAsStringAsync(ct);
            if (resp.IsSuccessStatusCode)
            {
                using var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                var newAccess = root.GetProperty("access_token").GetString()!;
                var newRefresh= root.TryGetProperty("refresh_token", out var rt) ? rt.GetString() : refresh;
                var expiresIn = root.TryGetProperty("expires_in", out var ei) ? ei.GetInt32() : 3600;
                var expAt     = DateTimeOffset.UtcNow.AddSeconds(expiresIn - 60);

                sess.SetString(SessAccessToken, newAccess);
                if (!string.IsNullOrEmpty(newRefresh)) sess.SetString(SessRefreshToken, newRefresh);
                sess.SetString(SessExpiresAt, expAt.ToUnixTimeSeconds().ToString());
                return newAccess;
            }
            // if refresh failed fall through to “not connected”
        }

        throw new InvalidOperationException("Not connected to Graph. Start with BuildAuthorizeUrl() and complete the callback.");
    }

    private string Need(string section, string key) =>
        _secrets.Get(section, key) ?? throw new InvalidOperationException($"Missing secret {section}:{key}");

    private string GetCallbackAbsoluteUrl()
    {
        var req = _http.HttpContext!.Request;
        var baseUri = $"{req.Scheme}://{req.Host}";
        return $"{baseUri}/graph/callback";
    }

    private static string CreateCodeVerifier()
    {
        // 43–128 chars, URL-safe
        var bytes = RandomNumberGenerator.GetBytes(64);
        return Base64Url(bytes);
    }

    private static string CreateCodeChallenge(string verifier)
    {
        using var sha256 = SHA256.Create();
        var hash = sha256.ComputeHash(Encoding.ASCII.GetBytes(verifier));
        return Base64Url(hash);
    }

    private static string Base64Url(ReadOnlySpan<byte> bytes) =>
        Convert.ToBase64String(bytes).TrimEnd('=').Replace('+','-').Replace('/','_');

    private static string ToQueryString(Dictionary<string,string?> kv)
    {
        var sb = new StringBuilder("?");
        bool first = true;
        foreach (var (k,v) in kv)
        {
            if (v is null) continue;
            if (!first) sb.Append('&'); first = false;
            sb.Append(Uri.EscapeDataString(k)).Append('=').Append(Uri.EscapeDataString(v));
        }
        return sb.ToString();
    }
}
Blazor pages to wire it up (tiny)
1) A “Connect” page that asks for username and navigates to the authorize URL
razor
Copy code
@page "/graph/connect"
@inject MicrosoftGraphApiService GraphSvc
@inject NavigationManager Nav

<h3>Connect to Graph</h3>
<input @bind="username" placeholder="user@contoso.com" />
<button class="btn btn-primary" @onclick="Connect">Connect</button>

@code {
    private string? username;

    private void Connect()
    {
        var scopes = new[]{
            "openid","profile","offline_access",
            "https://graph.microsoft.com/User.Read",
            "https://graph.microsoft.com/eDiscovery.Read.All"
        };
        var url = GraphSvc.BuildAuthorizeUrl(username, scopes);
        Nav.NavigateTo(url, forceLoad: true); // redirect to Azure sign-in
    }
}
2) A callback page that completes the token exchange
razor
Copy code
@page "/graph/callback"
@inject MicrosoftGraphApiService GraphSvc
@inject NavigationManager Nav
@using Microsoft.AspNetCore.WebUtilities

<p>Finishing sign-in…</p>

@code {
    protected override async Task OnInitializedAsync()
    {
        var uri = Nav.ToAbsoluteUri(Nav.Uri);
        var q = QueryHelpers.ParseQuery(uri.Query);
        if (q.TryGetValue("error", out var err))
            throw new InvalidOperationException($"{err} - {q["error_description"]}");

        var code  = q["code"].ToString();
        var state = q["state"].ToString();
        if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(state))
            throw new InvalidOperationException("Missing auth code or state.");

        await GraphSvc.CompleteAuthorizationAsync(code, state);
        Nav.NavigateTo("/graph/demo", replace: true);
    }
}
3) A demo page that calls Graph only after you connected
razor
Copy code
@page "/graph/demo"
@inject MicrosoftGraphApiService GraphSvc

<h3>Graph Demo</h3>
<button class="btn btn-secondary" @onclick="LoadMe">/me</button>
<button class="btn btn-secondary" @onclick="LoadCases">eDiscovery cases</button>

<pre>@output</pre>

@code {
    private string output = "";

    private async Task LoadMe()
    {
        try { output = (await GraphSvc.GetMeAsync())?.ToString() ?? "Not connected"; }
        catch (Exception ex) { output = ex.Message; }
    }

    private async Task LoadCases()
    {
        try { output = (await GraphSvc.ListEdiscoveryCasesAsync())?.ToString() ?? "No data"; }
        catch (Exception ex) { output = ex.Message; }
    }
}