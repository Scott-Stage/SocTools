// MyBackgroundService.cs

public class MyBackgroundService : BackgroundService
{
    // 1. Inject the IServiceScopeFactory. This is safe because the factory itself is a Singleton.
    private readonly IServiceScopeFactory _scopeFactory;

    public MyBackgroundService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // This loop runs for the entire application lifetime.
        while (!stoppingToken.IsCancellationRequested)
        {
            // --- This is the key part of the pattern ---
            
            // 2. For each unit of work, create a new, temporary DI scope.
            using (var scope = _scopeFactory.CreateScope())
            {
                // 3. Resolve your Scoped services from THIS temporary scope.
                // You are essentially creating a temporary "user session" for the background task.
                var appState = scope.ServiceProvider.GetRequiredService<AppState>();
                var taskRunner = scope.ServiceProvider.GetRequiredService<ComponentTaskRunner>();

                // 4. Now you can safely use these Scoped services inside this 'using' block.
                Console.WriteLine($"Background service checking status. Current AppState counter is {appState.Counter}");
                
                // You cannot hold onto the 'taskRunner' or 'appState' instances outside this block.
            }
            // The scope and all its services are automatically disposed of here.

            // 5. Wait before the next iteration.
            await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
        }
    }
}