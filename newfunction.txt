import os
import re
import string # Import string for punctuation handling

def read_software_list(filepath):
    """Reads a software list from a file, one item per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

def normalize_name(name):
    """
    Normalizes software name: lowercase, strip whitespace, remove punctuation,
    remove duplicate words, and rejoin sorted unique words.
    """
    if not name:
        return ""
    # Remove punctuation
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator)
    # Lowercase and strip leading/trailing whitespace
    name = name.lower().strip()
    # Reduce multiple spaces to single spaces
    name = re.sub(r'\s+', ' ', name)
    # Split into words, get unique words, sort them, and rejoin
    # Sorting ensures "word excel" and "excel word" normalize to the same string
    tokens = name.split()
    unique_sorted_tokens = sorted(list(set(tokens)))
    # Handle case where splitting results in empty list (e.g., input was only punctuation)
    if not unique_sorted_tokens:
        return ""
    return ' '.join(unique_sorted_tokens)

def compare_lists(my_software_list, db_software_list):
    """
    Compares the user's software list against the database list.
    - Exact Match: Normalized strings (incl. unique sorted tokens) are identical.
    - Partial Match: Token sets differ by exactly 1 unique token (symm diff = 1).

    Returns a dictionary containing categorized results.
    """
    if my_software_list is None or db_software_list is None:
        return None

    # Normalize database list and store originals
    db_normalized_map = {}
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized: # Ensure normalization didn't result in empty string
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
            db_normalized_map[normalized].append(db_item) # Store original name

    results = {
        'software_in_database': [],
        'partial_matches': {},
        'software_not_in_database': []
    }

    processed_my_software_normalized = set() # Keep track to avoid duplicates if my list has them

    # Pre-calculate token sets for the database for efficiency in partial matching
    db_token_sets = {}
    for db_norm, db_orig_list in db_normalized_map.items():
         db_token_sets[db_norm] = set(db_norm.split()) # Already normalized, just split


    for my_sw_orig in my_software_list:
        my_sw_norm = normalize_name(my_sw_orig)

        if not my_sw_norm or my_sw_norm in processed_my_software_normalized:
            continue # Skip empty normalized names or duplicates already processed

        found_match_type = None

        # 1. Check for Exact Match (post-FULL-normalization)
        # This now covers identical unique token sets because normalization handles it.
        if my_sw_norm in db_normalized_map:
            found_match_type = 'exact'
            # Record the original user software name as found
            results['software_in_database'].append(my_sw_orig)
            # Optionally, if you want to see *which* DB entries it matched exactly:
            # matched_db_exact = db_normalized_map[my_sw_norm]
            # print(f"Exact match for '{my_sw_orig}' ({my_sw_norm}) found with DB entries: {matched_db_exact}")
            processed_my_software_normalized.add(my_sw_norm)
            continue # Found exact match, move to next item

        # 2. If no exact normalized match, check for Partial Match (Symmetric Difference == 1)
        partial_found = False
        possible_partial_matches = []
        # Get token set for the current user software
        my_sw_tokens = set(my_sw_norm.split()) # Already normalized, just split
        my_sw_tokens.discard('') # Should be redundant now, but safe

        if not my_sw_tokens: # Should not happen if my_sw_norm is not empty, but safety check
             processed_my_software_normalized.add(my_sw_norm)
             results['software_not_in_database'].append(my_sw_orig)
             continue

        # Iterate through pre-calculated DB token sets
        for db_norm, db_tokens in db_token_sets.items():
            # No need to compare against empty set if it somehow occurred
            if not db_tokens:
                continue

            # Calculate symmetric difference
            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)

            # --- Partial Match Logic: Exactly 1 token difference ---
            # We already handled the symm_diff == 0 case via the exact match check above.
            # Check common tokens only needed if symm_diff could be > 1 and potentially match unrelated items.
            # If symm_diff == 1, it implies common tokens exist (unless both were single, different tokens).
            if len(symmetric_difference) == 1:
                 partial_found = True
                 # Add the *original* DB names corresponding to this normalized form
                 possible_partial_matches.extend(db_normalized_map[db_norm])


        if partial_found:
            found_match_type = 'partial'
            # Store original user name mapped to unique list of original DB names
            results['partial_matches'][my_sw_orig] = sorted(list(set(possible_partial_matches)))
        else:
            # 3. If no match of any kind found (neither exact nor partial with diff=1)
            results['software_not_in_database'].append(my_sw_orig)

        processed_my_software_normalized.add(my_sw_norm)

    return results

def write_results(output_file, results):
    """Writes the categorized results to a file."""
    if results is None:
        print("Skipping writing results due to previous errors.")
        return

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("=" * 30 + "\n")
            f.write("Software Comparison Results\n")
            f.write("=" * 30 + "\n\n")

            # --- Software Found Directly in Database ---
            f.write("=== Software Found Directly in Database (Exact Normalized Match) ===\n")
            f.write("    (Normalization includes lowercasing, punctuation removal, and duplicate word removal)\n")
            if results['software_in_database']:
                for item in sorted(results['software_in_database']):
                    f.write(f"- {item}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- Potential Partial Matches Found ---
            f.write("=== Potential Partial Matches Found (Difference = Exactly 1 Token) ===\n")
            if results['partial_matches']:
                for my_sw, db_matches in sorted(results['partial_matches'].items()):
                    f.write(f"- Your Software: {my_sw}\n")
                    f.write(f"  Potential DB Matches: {', '.join(db_matches)}\n")
            else:
                f.write("None\n")
            f.write("\n")

            # --- Software Not Found in Database ---
            f.write("=== Software NOT Found in Database (Exact or Partial) ===\n")
            if results['software_not_in_database']:
                for item in sorted(results['software_not_in_database']):
                    f.write(f"- {item}\n")
            else:
                f.write("None\n")
            f.write("\n")

        print(f"Results successfully written to {output_file}")

    except Exception as e:
        print(f"Error writing results to file {output_file}: {e}")

# --- Main Execution ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print("Comparing lists using enhanced normalization...")
        comparison_results = compare_lists(my_list, db_list)
        write_results(output_result_file, comparison_results)
    else:
        print("Comparison cancelled due to errors reading input files.")