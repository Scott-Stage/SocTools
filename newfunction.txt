// Services/ComponentTaskRunner.cs
using System.Collections.Concurrent;
using System.Threading;

public class ComponentTaskRunner : IDisposable
{
    // The dictionary now holds the complete state for each task.
    private readonly ConcurrentDictionary<string, TaskState> _runningTasks = new();

    private record TaskState(CancellationTokenSource Cts, SemaphoreSlim Lock);

    // Start needs the maxConcurrency parameter again.
    public void Start(
        string taskName,
        TimeSpan interval,
        int maxConcurrency, // e.g., 1 for "skip if busy"
        Action onStateHasChanged,
        params Func<Task>[] workFunctions)
    {
        // Create the complete state package for the new task.
        var newState = new TaskState(
            new CancellationTokenSource(),
            new SemaphoreSlim(maxConcurrency, maxConcurrency)
        );

        // If a task with this name isn't already running, add it.
        if (!_runningTasks.TryAdd(taskName, newState))
        {
            // A task with this name already exists, so we don't start a new one.
            // We also need to clean up the state we just created.
            newState.Cts.Dispose();
            newState.Lock.Dispose();
            return;
        }

        _ = DoContinuousWorkAsync(taskName, interval, onStateHasChanged, workFunctions, newState);
    }

    public void Stop(string taskName)
    {
        if (_runningTasks.TryRemove(taskName, out var taskState))
        {
            taskState.Cts.Cancel();
            taskState.Cts.Dispose();
            taskState.Lock.Dispose(); // Clean up the semaphore too.
        }
    }

    // ... IsRunning() and StopAll() methods remain the same ...

    private async Task DoContinuousWorkAsync(string taskName, TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, TaskState taskState)
    {
        while (!taskState.Cts.IsCancellationRequested)
        {
            try { await Task.Delay(interval, taskState.Cts.Token); }
            catch (OperationCanceledException) { break; }

            // Use the task's personal lock to control concurrency.
            // A timeout of 0 means "skip if busy".
            if (!await taskState.Lock.WaitAsync(0, taskState.Cts.Token))
            {
                Console.WriteLine($"Skipping tick for task '{taskName}' because it is already running.");
                continue;
            }

            try
            {
                // We have acquired the lock for this specific task.
                await Task.Run(async () =>
                {
                    foreach (var work in workFunctions)
                    {
                        if (taskState.Cts.IsCancellationRequested) break;
                        await work();
                    }
                }, taskState.Cts.Token);

                if (!taskState.Cts.IsCancellationRequested)
                {
                    onStateHasChanged?.Invoke();
                }
            }
            finally
            {
                // Release this task's personal lock.
                taskState.Lock.Release();
            }
        }
    }
    
    // ... other methods
    public void Dispose() => StopAll();
}