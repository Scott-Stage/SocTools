@page "/acl-parser"

<PageTitle>ACL Parser</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="py-6 acl-parser-page">
    <MudStack Spacing="3">
        <MudPaper Elevation="2" Class="p-4">
            <MudStack Spacing="2">
                <MudText Typo="Typo.h5" Class="font-weight-bold">Cisco ACL Parser</MudText>
                <MudText Typo="Typo.body2" Class="text-secondary">
                    Drop a Cisco ACL config file to extract source, destination, protocol, and rule metadata.
                </MudText>
                <div class="acl-drop-zone">
                    <InputFile OnChange="HandleFileSelected" class="acl-drop-input" accept=".txt,.cfg,.conf,.acl" />
                    <div class="acl-drop-content">
                        <MudText Typo="Typo.subtitle1" Class="font-weight-bold">Drag &amp; drop a config file</MudText>
                        <MudText Typo="Typo.caption" Class="text-secondary">or click to browse</MudText>
                        @if (!string.IsNullOrWhiteSpace(UploadedFileName))
                        {
                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined">
                                @UploadedFileName
                            </MudChip>
                        }
                    </div>
                </div>
                @if (IsLoading)
                {
                    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                }
                else if (Entries.Count > 0)
                {
                    <MudStack Direction="Row" Spacing="2" AlignItems="AlignItems.Center">
                        <MudChip T="string" Color="Color.Info" Variant="Variant.Filled">Entries: @Entries.Count</MudChip>
                        <MudChip T="string" Color="Color.Success" Variant="Variant.Filled">Permits: @Entries.Count(e => e.Action == "permit")</MudChip>
                        <MudChip T="string" Color="Color.Error" Variant="Variant.Filled">Denies: @Entries.Count(e => e.Action == "deny")</MudChip>
                        <MudChip T="string" Color="Color.Default" Variant="Variant.Filled">Remarks: @Entries.Count(e => e.Action == "remark")</MudChip>
                        @if (UploadedAt is not null)
                        {
                            <MudText Typo="Typo.caption" Class="text-secondary">
                                Parsed @UploadedAt.Value.ToString("g")
                            </MudText>
                        }
                    </MudStack>
                }
                @if (ParseWarnings.Count > 0)
                {
                    <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">
                        @foreach (var warning in ParseWarnings)
                        {
                            <div>@warning</div>
                        }
                    </MudAlert>
                }
            </MudStack>
        </MudPaper>

        <MudPaper Elevation="2" Class="p-4">
            <MudText Typo="Typo.subtitle1" Class="font-weight-bold mb-2">Rules</MudText>
            <div class="acl-table-scroll">
                <MudTable Items="Entries"
                          Dense="true"
                          Hover="true"
                          Striped="true"
                          RowClassFunc="GetRowClass"
                          RowClick="HandleRowClick">
                    <HeaderContent>
                        <MudTh>#</MudTh>
                        <MudTh>ACL Name</MudTh>
                        <MudTh>Interface</MudTh>
                        <MudTh>Action</MudTh>
                        <MudTh>Protocol</MudTh>
                        <MudTh>Source</MudTh>
                        <MudTh>Dest</MudTh>
                        <MudTh>Dest Port</MudTh>
                        <MudTh>Remark</MudTh>
                        <MudTh>Log</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="#">@context.Occurrence</MudTd>
                        <MudTd DataLabel="ACL Name">@context.AclName</MudTd>
                        <MudTd DataLabel="Interface">@context.Interface</MudTd>
                        <MudTd DataLabel="Action">
                            <MudChip T="string" Color="@GetActionColor(context.Action)" Variant="Variant.Filled" Size="Size.Small">
                                @context.Action
                            </MudChip>
                        </MudTd>
                        <MudTd DataLabel="Protocol">@context.Protocol</MudTd>
                        <MudTd DataLabel="Source">@context.Source</MudTd>
                        <MudTd DataLabel="Dest">@context.Destination</MudTd>
                        <MudTd DataLabel="Dest Port">@context.DestinationPort</MudTd>
                        <MudTd DataLabel="Remark">@context.Remark</MudTd>
                        <MudTd DataLabel="Log">
                            @if (context.Log)
                            {
                                <MudChip T="string" Color="Color.Info" Variant="Variant.Filled" Size="Size.Small">log</MudChip>
                            }
                        </MudTd>
                    </RowTemplate>
                    <NoRecordsContent>
                        <MudText Typo="Typo.body2" Class="text-secondary">Upload a config to see parsed ACL rules.</MudText>
                    </NoRecordsContent>
                </MudTable>
            </div>
        </MudPaper>

        <MudPaper Elevation="2" Class="p-4">
            <MudText Typo="Typo.subtitle1" Class="font-weight-bold mb-2">Rule Details</MudText>
            <MudTable Items="DetailRows" Dense="true" Hover="true" Striped="true">
                <HeaderContent>
                    <MudTh>Protocol Info</MudTh>
                    <MudTh>Source Info</MudTh>
                    <MudTh>Destination Info</MudTh>
                    <MudTh>Dest. Port Info</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Protocol Info">
                        <div class="acl-detail-cell">@context.ProtocolInfo</div>
                    </MudTd>
                    <MudTd DataLabel="Source Info">
                        <div class="acl-detail-cell">@context.SourceInfo</div>
                    </MudTd>
                    <MudTd DataLabel="Destination Info">
                        <div class="acl-detail-cell">@context.DestinationInfo</div>
                    </MudTd>
                    <MudTd DataLabel="Dest. Port Info">
                        <div class="acl-detail-cell">@context.DestinationPortInfo</div>
                    </MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    <MudText Typo="Typo.body2" Class="text-secondary">Select a rule to view details.</MudText>
                </NoRecordsContent>
            </MudTable>
        </MudPaper>
    </MudStack>
</MudContainer>

<style>
    .acl-drop-zone {
        position: relative;
        border: 2px dashed rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 24px;
        min-height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, rgba(233, 243, 255, 0.7), rgba(255, 250, 230, 0.7));
    }

    .acl-drop-input {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
    }

    .acl-drop-content {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: center;
    }

    .acl-row-deny {
        background-color: rgba(244, 67, 54, 0.08);
    }

    .acl-row-remark {
        background-color: rgba(158, 158, 158, 0.08);
    }

    .acl-row-selected {
        outline: 2px solid rgba(33, 150, 243, 0.35);
        outline-offset: -2px;
    }

    .acl-table-scroll {
        max-height: 45vh;
        overflow: auto;
    }

    .acl-detail-cell {
        white-space: pre-wrap;
    }
</style>

@code {
    private readonly List<AclEntry> Entries = new();
    private readonly List<string> ParseWarnings = new();
    private readonly List<AclDetailRow> DetailRows = new();
    private string? UploadedFileName;
    private DateTime? UploadedAt;
    private bool IsLoading;
    private AclEntry? SelectedEntry;

    private async Task HandleFileSelected(InputFileChangeEventArgs args)
    {
        var file = args.File;
        if (file is null)
        {
            return;
        }

        IsLoading = true;
        ParseWarnings.Clear();
        Entries.Clear();

        try
        {
            await using var stream = file.OpenReadStream(maxAllowedSize: 10_000_000);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();

            UploadedFileName = file.Name;
            UploadedAt = DateTime.Now;
            Entries.AddRange(ParseAcl(content));
            SelectedEntry = Entries.FirstOrDefault();
            BuildDetailRows();
        }
        catch (Exception ex)
        {
            ParseWarnings.Add($"Unable to parse file: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
        }
    }

    private IEnumerable<AclEntry> ParseAcl(string content)
    {
        var results = new List<AclEntry>();
        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        string? currentAclName = null;
        var inNamedAcl = false;

        for (var i = 0; i < lines.Length; i++)
        {
            var rawLine = lines[i];
            var lineNumber = i + 1;
            var trimmed = rawLine.Trim();

            if (string.IsNullOrWhiteSpace(trimmed))
            {
                continue;
            }

            if (trimmed.StartsWith("!", StringComparison.Ordinal) || trimmed.StartsWith("#", StringComparison.Ordinal))
            {
                continue;
            }

            var tokens = Tokenize(trimmed);
            if (tokens.Length == 0)
            {
                continue;
            }

            if (tokens.Length >= 3 &&
                tokens[0].Equals("ip", StringComparison.OrdinalIgnoreCase) &&
                tokens[1].Equals("access-list", StringComparison.OrdinalIgnoreCase))
            {
                if (tokens.Length >= 4)
                {
                    currentAclName = tokens[3];
                    inNamedAcl = true;
                }

                continue;
            }

            if (tokens[0].Equals("exit", StringComparison.OrdinalIgnoreCase) ||
                tokens[0].Equals("end", StringComparison.OrdinalIgnoreCase))
            {
                currentAclName = null;
                inNamedAcl = false;
                continue;
            }

            var entry = TryParseAclEntry(tokens, lineNumber, trimmed, currentAclName, inNamedAcl);
            if (entry is null)
            {
                if (LooksLikeAclLine(tokens))
                {
                    ParseWarnings.Add($"Line {lineNumber}: Unrecognized ACL syntax.");
                }
                continue;
            }

            results.Add(entry with { Occurrence = results.Count + 1 });
        }

        return results;
    }

    private static string[] Tokenize(string line)
    {
        return line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    }

    private static bool LooksLikeAclLine(string[] tokens)
    {
        if (tokens.Length == 0)
        {
            return false;
        }

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (IsSequenceNumber(tokens[0]) && tokens.Length > 1)
        {
            var actionAfterSequence = tokens[1];
            return IsActionToken(actionAfterSequence) || actionAfterSequence.Equals("remark", StringComparison.OrdinalIgnoreCase);
        }

        var action = tokens[0];
        return IsActionToken(action) || action.Equals("remark", StringComparison.OrdinalIgnoreCase);
    }

    private static AclEntry? TryParseAclEntry(string[] tokens, int lineNumber, string raw, string? currentAclName, bool inNamedAcl)
    {
        var index = 0;
        var aclName = currentAclName;

        if (tokens[0].Equals("access-list", StringComparison.OrdinalIgnoreCase))
        {
            if (tokens.Length < 3)
            {
                return null;
            }

            aclName = tokens[1];
            index = 2;
        }
        else if (!IsActionToken(tokens[0]) && !tokens[0].Equals("remark", StringComparison.OrdinalIgnoreCase))
        {
            if (!inNamedAcl)
            {
                return null;
            }

            index = 0;
        }

        if (index < tokens.Length && tokens[index].Equals("line", StringComparison.OrdinalIgnoreCase))
        {
            if (index + 1 < tokens.Length && IsSequenceNumber(tokens[index + 1]))
            {
                index += 2;
            }
        }

        if (index < tokens.Length && IsSequenceNumber(tokens[index]))
        {
            index++;
        }

        if (index < tokens.Length && IsAclTypeToken(tokens[index]))
        {
            index++;
        }

        if (index >= tokens.Length)
        {
            return null;
        }

        var action = tokens[index].ToLowerInvariant();
        if (action == "remark")
        {
            var comment = string.Join(' ', tokens.Skip(index + 1));
            return new AclEntry(
                lineNumber,
                0,
                raw,
                aclName ?? string.Empty,
                string.Empty,
                action,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                string.Empty,
                comment,
                false);
        }

        if (!IsActionToken(action))
        {
            return null;
        }

        index++;
        var protocol = index < tokens.Length ? tokens[index].ToLowerInvariant() : "ip";
        if (protocol is "object" or "object-group")
        {
            if (index + 1 < tokens.Length)
            {
                protocol = $"{protocol} {tokens[index + 1]}";
                index += 2;
            }
            else
            {
                index++;
            }
        }
        else
        {
            index++;
        }

        var (source, afterSource) = ParseAddress(tokens, index);
        index = afterSource;

        var (sourcePort, afterSourcePort) = ParsePort(tokens, index);
        if (afterSourcePort != index)
        {
            index = afterSourcePort;
        }

        var (destination, afterDestination) = ParseAddress(tokens, index);
        index = afterDestination;

        var (destinationPort, afterDestinationPort) = ParsePort(tokens, index);
        if (afterDestinationPort != index)
        {
            index = afterDestinationPort;
        }

        var options = index < tokens.Length ? string.Join(' ', tokens.Skip(index)) : string.Empty;
        var log = ContainsLog(tokens, index);
        var iface = ExtractInterface(source, destination, options);

        return new AclEntry(
            lineNumber,
            0,
            raw,
            aclName ?? string.Empty,
            iface,
            action,
            protocol,
            source,
            sourcePort,
            destination,
            destinationPort,
            options,
            string.Empty,
            log);
    }

    private static (string Value, int NextIndex) ParseAddress(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start];
        if (token.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            return ("any", start + 1);
        }

        if (token.Equals("host", StringComparison.OrdinalIgnoreCase) && start + 1 < tokens.Length)
        {
            return ($"host {tokens[start + 1]}", start + 2);
        }

        if ((token.Equals("object", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("object-group", StringComparison.OrdinalIgnoreCase) ||
             token.Equals("interface", StringComparison.OrdinalIgnoreCase)) &&
            start + 1 < tokens.Length)
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (LooksLikeIp(token) && start + 1 < tokens.Length && LooksLikeIp(tokens[start + 1]))
        {
            return ($"{token} {tokens[start + 1]}", start + 2);
        }

        if (token.Contains('/', StringComparison.Ordinal))
        {
            return (token, start + 1);
        }

        return (token, start + 1);
    }

    private static (string Value, int NextIndex) ParsePort(string[] tokens, int start)
    {
        if (start >= tokens.Length)
        {
            return (string.Empty, start);
        }

        var token = tokens[start].ToLowerInvariant();
        if (token is "eq" or "gt" or "lt" or "neq")
        {
            return start + 1 < tokens.Length
                ? ($"{token} {tokens[start + 1]}", start + 2)
                : (token, start + 1);
        }

        if (token == "range")
        {
            return start + 2 < tokens.Length
                ? ($"{token} {tokens[start + 1]} {tokens[start + 2]}", start + 3)
                : (token, start + 1);
        }

        return (string.Empty, start);
    }

    private static bool IsActionToken(string token)
    {
        return token.Equals("permit", StringComparison.OrdinalIgnoreCase) ||
               token.Equals("deny", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsAclTypeToken(string token)
    {
        return token.Equals("extended", StringComparison.OrdinalIgnoreCase) ||
               token.Equals("standard", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsSequenceNumber(string token)
    {
        return int.TryParse(token, out _);
    }

    private static bool LooksLikeIp(string token)
    {
        return System.Net.IPAddress.TryParse(token, out _);
    }

    private static bool ContainsLog(string[] tokens, int start)
    {
        for (var i = start; i < tokens.Length; i++)
        {
            if (tokens[i].Equals("log", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }

        return false;
    }

    private static string ExtractInterface(string source, string destination, string options)
    {
        if (source.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            return source.Substring("interface ".Length);
        }

        if (destination.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            return destination.Substring("interface ".Length);
        }

        if (options.Contains("interface ", StringComparison.OrdinalIgnoreCase))
        {
            var parts = options.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            for (var i = 0; i < parts.Length - 1; i++)
            {
                if (parts[i].Equals("interface", StringComparison.OrdinalIgnoreCase))
                {
                    return parts[i + 1];
                }
            }
        }

        return string.Empty;
    }

    private static Color GetActionColor(string action)
    {
        return action switch
        {
            "permit" => Color.Success,
            "deny" => Color.Error,
            "remark" => Color.Default,
            _ => Color.Info
        };
    }

    private string GetRowClass(AclEntry entry, int index)
    {
        var baseClass = entry.Action switch
        {
            "deny" => "acl-row-deny",
            "remark" => "acl-row-remark",
            _ => string.Empty
        };

        if (SelectedEntry is not null && entry.Occurrence == SelectedEntry.Occurrence)
        {
            return string.IsNullOrWhiteSpace(baseClass) ? "acl-row-selected" : $"{baseClass} acl-row-selected";
        }

        return baseClass;
    }

    private void HandleRowClick(TableRowClickEventArgs<AclEntry> args)
    {
        SelectedEntry = args.Item;
        BuildDetailRows();
    }

    private void BuildDetailRows()
    {
        DetailRows.Clear();

        if (SelectedEntry is null)
        {
            return;
        }

        DetailRows.Add(new AclDetailRow(
            DescribeProtocol(SelectedEntry),
            DescribeAddress(SelectedEntry.Source),
            DescribeAddress(SelectedEntry.Destination),
            DescribeDestinationPort(SelectedEntry)));
    }

    private static string DescribeProtocol(AclEntry entry)
    {
        if (string.IsNullOrWhiteSpace(entry.Protocol))
        {
            return "Not set";
        }

        if (entry.Protocol.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Service group: {entry.Protocol.Replace("object-group ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        if (entry.Protocol.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Service object: {entry.Protocol.Replace("object ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        return $"Protocol: {entry.Protocol}";
    }

    private static string DescribeAddress(string address)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            return "Not set";
        }

        if (address.Equals("any", StringComparison.OrdinalIgnoreCase))
        {
            return "Any";
        }

        if (address.StartsWith("host ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Host: {address.Replace("host ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        if (address.StartsWith("object-group ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Object group: {address.Replace("object-group ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        if (address.StartsWith("object ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Object: {address.Replace("object ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        if (address.StartsWith("interface ", StringComparison.OrdinalIgnoreCase))
        {
            return $"Interface: {address.Replace("interface ", string.Empty, StringComparison.OrdinalIgnoreCase)}";
        }

        return $"Network: {address}";
    }

    private static string DescribeDestinationPort(AclEntry entry)
    {
        if (!string.IsNullOrWhiteSpace(entry.DestinationPort))
        {
            return $"Port: {entry.DestinationPort}";
        }

        if (!string.IsNullOrWhiteSpace(entry.Remark))
        {
            return $"Remark: {entry.Remark}";
        }

        return "Not set";
    }

    private sealed record AclEntry(
        int LineNumber,
        int Occurrence,
        string Raw,
        string AclName,
        string Interface,
        string Action,
        string Protocol,
        string Source,
        string SourcePort,
        string Destination,
        string DestinationPort,
        string Options,
        string Remark,
        bool Log);

    private sealed record AclDetailRow(
        string ProtocolInfo,
        string SourceInfo,
        string DestinationInfo,
        string DestinationPortInfo);
}
