import os
import re
import string

# --- Configuration ---
DEBUG = False # Set to True to see detailed comparison steps

def read_software_list(filepath):
    """Reads a software list from a file, one item per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            software_list = [line.strip() for line in f if line.strip()]
        return software_list
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

def normalize_name(name):
    """
    Normalizes software name: lowercase, strip whitespace, remove punctuation,
    remove duplicate words, and rejoin sorted unique words.
    """
    if not name:
        return ""
    translator = str.maketrans('', '', string.punctuation)
    name = name.translate(translator)
    name = name.lower().strip()
    name = re.sub(r'\s+', ' ', name)
    tokens = name.split()
    unique_sorted_tokens = sorted(list(set(filter(None, tokens))))
    if not unique_sorted_tokens:
        return ""
    return ' '.join(unique_sorted_tokens)

def calculate_jaccard_distance(set1, set2):
    """ Calculates Jaccard distance: len(symm_diff) / len(union) """
    sym_diff = set1.symmetric_difference(set2)
    union = set1.union(set2)
    if not union: return 0.0
    return len(sym_diff) / len(union)


def compare_lists(my_software_list, db_software_list):
    """
    Compares lists with refined Full/Partial match criteria.
    - Full Match: (Symm Diff <= 1) OR (Partial Criteria Met AND Jaccard Dist <= 0.5).
    - Partial Match: Partial Criteria Met AND Jaccard Dist > 0.5.
    """
    if my_software_list is None or db_software_list is None:
        return None

    # --- Prepare Database Data ---
    db_normalized_map = {}
    db_token_sets = {}
    print("Normalizing database entries...")
    for db_item in db_software_list:
        normalized = normalize_name(db_item)
        if normalized:
            if normalized not in db_normalized_map:
                db_normalized_map[normalized] = []
                db_token_sets[normalized] = set(filter(None, normalized.split()))
            db_normalized_map[normalized].append(db_item)
    if DEBUG: print(f"Normalized DB forms: {list(db_token_sets.keys())}")

    # --- Initialize Results ---
    results = {
        'full_matches': [],
        'partial_matches': {}, # Dict: {orig 'my_sw': {'db_matches': [], 'min_diff_percent': float}}
        'not_found': []
    }
    processed_my_software_originals = set()

    # --- Compare Each Item in My List ---
    print("\nComparing your software list...")
    for i, my_sw_orig in enumerate(my_software_list):
        if my_sw_orig in processed_my_software_originals:
            if DEBUG: print(f"\nSkipping duplicate entry: '{my_sw_orig}'")
            continue

        if DEBUG: print(f"\n--- Comparing Your Software ({i+1}): '{my_sw_orig}' ---")
        my_sw_norm = normalize_name(my_sw_orig)

        if not my_sw_norm:
            if DEBUG: print(f"  Normalized to empty, classifying as Not Found.")
            results['not_found'].append(my_sw_orig)
            processed_my_software_originals.add(my_sw_orig)
            continue

        my_sw_tokens = set(filter(None, my_sw_norm.split()))
        if not my_sw_tokens:
            if DEBUG: print(f"  Token set empty, classifying as Not Found.")
            results['not_found'].append(my_sw_orig)
            processed_my_software_originals.add(my_sw_orig)
            continue

        if DEBUG: print(f"  Normalized: '{my_sw_norm}' | Tokens: {my_sw_tokens}")

        # --- Check Against Database Entries ---
        current_match_level = 'none' # none, partial, full
        partial_match_candidates = []
        min_partial_jaccard_dist = 1.1 # Initialize > 1.0
        found_direct_full_match = False # Flag if symm diff <= 1 was met
        db_check_counter = 0

        for db_norm, db_tokens in db_token_sets.items():
            db_check_counter += 1
            if not db_tokens: continue

            if DEBUG: print(f"  Checking against DB entry {db_check_counter}: '{db_norm}' | Tokens: {db_tokens}")

            symmetric_difference = my_sw_tokens.symmetric_difference(db_tokens)
            sym_diff_len = len(symmetric_difference)
            jaccard_dist = calculate_jaccard_distance(my_sw_tokens, db_tokens)

            if DEBUG: print(f"    Symm Diff: {symmetric_difference} (Size: {sym_diff_len}) | Jaccard Dist: {jaccard_dist:.4f}")

            # --- Check for Direct Full Match (Symm Diff <= 1 takes precedence) ---
            if sym_diff_len <= 1:
                if DEBUG: print(f"    --> Direct Full Match found (Symm Diff <= 1).")
                current_match_level = 'full'
                found_direct_full_match = True
                break # Exit inner loop, highest priority match found

            # --- Check for Partial Match Criteria (only if direct full match not found yet) ---
            is_proper_subset_my_in_db = my_sw_tokens.issubset(db_tokens) and my_sw_tokens != db_tokens
            is_proper_subset_db_in_my = db_tokens.issubset(my_sw_tokens) and my_sw_tokens != db_tokens

            partial_match_criteria_met = False
            if is_proper_subset_my_in_db and len(my_sw_tokens) >= 2:
                 if DEBUG: print(f"    --> Partial Match criteria met (My tokens >=2 subset of DB tokens).")
                 partial_match_criteria_met = True
            elif is_proper_subset_db_in_my and len(db_tokens) >= 2:
                 if DEBUG: print(f"    --> Partial Match criteria met (DB tokens >=2 subset of My tokens).")
                 partial_match_criteria_met = True

            if partial_match_criteria_met:
                 # This comparison meets the partial criteria. Record its details.
                 current_match_level = 'partial' # Mark that we found at least one partial
                 partial_match_candidates.extend(db_normalized_map[db_norm])
                 min_partial_jaccard_dist = min(min_partial_jaccard_dist, jaccard_dist)
                 if DEBUG: print(f"    --> Recording potential Partial Match. Min Dist so far: {min_partial_jaccard_dist:.4f}. Candidates: {set(partial_match_candidates)}")
            elif DEBUG:
                 print(f"    --> No Full or Partial match criteria met with this DB entry.")

            # NOTE: Inner loop continues even if partial found, to check all DB entries for a potential direct full match.

        # --- Categorize Result for my_sw_orig (After checking all DB entries) ---
        if found_direct_full_match: # Highest priority
            results['full_matches'].append(my_sw_orig)
            if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Direct Symm Diff <= 1)")
        elif current_match_level == 'partial':
            # We found partial matches, but no direct full match. Now check Jaccard distance.
            if min_partial_jaccard_dist <= 0.5: # Reclassify as Full Match based on threshold
                results['full_matches'].append(my_sw_orig)
                if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Full Match (Promoted from Partial, Min Jaccard Dist <= 50%)")
            else: # Keep as Partial Match
                min_diff_percent = round(min_partial_jaccard_dist * 100, 2)
                results['partial_matches'][my_sw_orig] = {
                    'db_matches': sorted(list(set(partial_match_candidates))),
                    'min_diff_percent': min_diff_percent
                }
                if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Partial Match (Min Diff: {min_diff_percent}%, Jaccard > 50%)")
        else: # current_match_level == 'none'
            results['not_found'].append(my_sw_orig)
            if DEBUG: print(f"  FINAL Classification for '{my_sw_orig}': Not Found")

        processed_my_software_originals.add(my_sw_orig)

    print("\nComparison complete.")
    return results

def write_results(output_file, results):
    """Writes the categorized results to a file."""
    if results is None:
        print("Skipping writing results due to previous errors.")
        return

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("=" * 40 + "\n")
            f.write("Software Comparison Results\n")
            f.write("=" * 40 + "\n\n")

            f.write("=== Full Matches Found in Database ===\n")
            f.write("    (Criteria: Unique token sets differ by <=1 token OR \n")
            f.write("     Partial Match criteria met with Min Jaccard Distance <= 50%)\n")
            if results['full_matches']:
                for item in sorted(results['full_matches']):
                    f.write(f"- {item}\n")
            else:
                f.write("None\n")
            f.write("\n")

            f.write("=== Partial Matches Found in Database ===\n")
            f.write("    (Criteria: One name proper subset (size>=2) of other; Not a Full Match;\n")
            f.write("     AND Min Jaccard Distance > 50%)\n")
            if results['partial_matches']:
                for my_sw, match_data in sorted(results['partial_matches'].items()):
                    db_matches = match_data['db_matches']
                    percent_diff = match_data['min_diff_percent']
                    f.write(f"- Your Software: {my_sw}\n")
                    f.write(f"  (Min Difference: {percent_diff:.2f}%) Potential DB Matches: {', '.join(db_matches)}\n")
            else:
                f.write("None\n")
            f.write("\n")

            f.write("=== Software NOT Found in Database ===\n")
            f.write("    (No DB entry met Full or Partial match criteria)\n")
            if results['not_found']:
                for item in sorted(results['not_found']):
                    f.write(f"- {item}\n")
            else:
                f.write("None\n")
            f.write("\n")

        print(f"\nResults successfully written to {output_file}")

    except Exception as e:
        print(f"Error writing results to file {output_file}: {e}")

# --- Main Execution ---
if __name__ == "__main__":
    my_software_file = "my_software.txt"
    db_software_file = "database_software.txt"
    output_result_file = "comparison_results.txt"

    print(f"Reading your software list from: {my_software_file}")
    my_list = read_software_list(my_software_file)

    print(f"Reading database software list from: {db_software_file}")
    db_list = read_software_list(db_software_file)

    if my_list is not None and db_list is not None:
        print("Comparing lists using specific Full/Partial match criteria with Jaccard threshold...")
        comparison_results = compare_lists(my_list, db_list)
        write_results(output_result_file, comparison_results)
    else:
        print("Comparison cancelled due to errors reading input files.")