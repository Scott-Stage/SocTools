@page "/file-reader"
@using System.IO
@using System.Text
@using System.Threading
@inject IJSRuntime JSRuntime
@implements IDisposable

<h1>Real-time File Content Viewer</h1>

<p>
    <label for="filePath">File Path:</label>
    <input id="filePath" @bind="filePath" style="width: 500px;" />
</p>

<p>
    <label for="refreshInterval">Refresh Interval (ms):</label>
    <input id="refreshInterval" type="number" @bind="refreshInterval" />
</p>

<button class="btn btn-primary" @onclick="StartReading">Start Reading</button>
<button class="btn btn-secondary" @onclick="StopReading">Stop Reading</button>

<hr />

<h3>File Content:</h3>

<!-- 1. The scrollable container with an id -->
<div id="file-content-container" style="height: 800px; overflow-y: scroll; border: 1px solid #ccc; background-color: #f5f5f5;">
    <pre>@fileContent</pre>
</div>

@code {
    private string? filePath = "C:\\path\\to\\your\\file.txt"; // TODO: Change this to the path of the file you want to monitor.
    private int refreshInterval = 1000;
    private string? fileContent;
    private Timer? timer;
    private bool shouldScrollToBottom = false;

    private void StartReading()
    {
        timer?.Dispose();
        timer = new Timer(async _ => await ReadFile(), null, 0, refreshInterval);
    }

    private async Task ReadFile()
    {
        try
        {
            if (File.Exists(filePath))
            {
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                {
                    string newContent = await streamReader.ReadToEndAsync();
                    if (newContent != fileContent)
                    {
                        fileContent = newContent;
                        shouldScrollToBottom = true; // Flag that a scroll is needed
                    }
                }
            }
            else
            {
                fileContent = "File not found.";
            }
        }
        catch (Exception ex)
        {
            fileContent = $"Error reading file: {ex.Message}";
        }
        
        await InvokeAsync(StateHasChanged);
    }

    // 2. This method is called after the component has rendered.
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldScrollToBottom)
        {
            // 3. Call the JavaScript function to scroll the div.
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "file-content-container");
            shouldScrollToBottom = false; // Reset the flag
        }
    }

    private void StopReading()
    {
        timer?.Dispose();
    }

    public void Dispose()
    {
        timer?.Dispose();
    }
}




    ...
    <script src="_framework/blazor.server.js"></script>

    <!-- 4. Add this script -->
    <script>
      window.scrollToBottom = (elementId) => {
        var element = document.getElementById(elementId);
        if (element) {
          element.scrollTop = element.scrollHeight;
        }
      };
    </script>
</body>
</html>