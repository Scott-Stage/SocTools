<MudTable Items="@_cipherSuiteList"
          Hover="true"
          Striped="true"
          Dense="true"
          IsLoading="_isLoading"
          Filter="new Func<CipherSuiteInfo, bool>(MultiFilterFunc)"
          @bind-SelectedItem="_selectedItem">

    <ToolBarContent>
        <MudText Typo="Typo.h6">Available Cipher Suites</MudText>
        <MudSpacer />
        @* MODIFICATION 1: Changed to a multi-line text field *@
        <MudTextField @bind-Value="_searchTermsInput"
                      Placeholder="Paste one or more cipher names, separated by new lines..."
                      Lines="5"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      IconSize="Size.Medium"
                      Class="mt-0" 
                      Style="width: 50%;" />
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel SortBy="new Func<CipherSuiteInfo, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel SortBy="new Func<CipherSuiteInfo, object>(x => x.Security)">Security</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel SortBy="new Func<CipherSuiteInfo, object>(x => x.KexAlgorithm)">Key Exchange</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel SortBy="new Func<CipherSuiteInfo, object>(x => x.EncAlgorithm)">Encryption</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel SortBy="new Func<CipherSuiteInfo, object>(x => x.TlsVersions)">TLS Versions</MudTableSortLabel></MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Name">@context.Name</MudTd>
        <MudTd DataLabel="Security">
            <MudChip Label="true" Color="@GetSecurityColor(context.Security)" Size="Size.Small">@context.Security</MudChip>
        </MudTd>
        <MudTd DataLabel="Key Exchange">@context.KexAlgorithm</MudTd>
        <MudTd DataLabel="Encryption">@context.EncAlgorithm</MudTd>
        <MudTd DataLabel="TLS Versions">@context.TlsVersions</MudTd>
    </RowTemplate>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>

@code {
    private bool _isLoading = true;
    private CipherSuiteInfo? _selectedItem;
    private List<CipherSuiteInfo> _cipherSuiteList = new();

    // MODIFICATION 2: Renamed the bound variable for clarity
    private string _searchTermsInput = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadCipherSuites();
    }

    private async Task LoadCipherSuites()
    {
        _isLoading = true;
        try
        {
            const string apiUrl = "https://ciphersuite.info/api/cs";
            var apiResponse = await Http.GetFromJsonAsync<CipherSuiteApiResponse>(apiUrl);

            if (apiResponse?.CipherSuites != null)
            {
                _cipherSuiteList = apiResponse.CipherSuites
                    .SelectMany(dict => dict)
                    .Select(kvp => new CipherSuiteInfo
                    {
                        Name = kvp.Key,
                        Security = kvp.Value.Security,
                        KexAlgorithm = kvp.Value.KexAlgorithm,
                        AuthAlgorithm = kvp.Value.AuthAlgorithm,
                        EncAlgorithm = kvp.Value.EncAlgorithm,
                        HashAlgorithm = kvp.Value.HashAlgorithm,
                        TlsVersions = string.Join(", ", kvp.Value.TlsVersion)
                    })
                    .OrderBy(c => c.Name)
                    .ToList();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching or processing cipher suites: {ex.Message}");
        }
        finally
        {
            _isLoading = false;
        }
    }

    // MODIFICATION 3: New filtering function for multiple, exact matches
    private bool MultiFilterFunc(CipherSuiteInfo element)
    {
        // If the input box is empty or just whitespace, show all rows.
        if (string.IsNullOrWhiteSpace(_searchTermsInput))
        {
            return true;
        }

        // Split the input text into individual lines, trim whitespace from each,
        // and remove any empty lines that might result from the split.
        // We use a HashSet for extremely fast lookups (O(1) average), which is
        // much more efficient than searching a List (O(n)) repeatedly.
        // StringComparer.OrdinalIgnoreCase ensures that the matching is not case-sensitive.
        var searchTerms = new HashSet<string>(
            _searchTermsInput.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
                             .Select(line => line.Trim()),
            StringComparer.OrdinalIgnoreCase
        );

        // If the processed set of terms is empty, there's nothing to filter by, so show all rows.
        if (!searchTerms.Any())
        {
            return true;
        }

        // Return true (show the row) if the element's name is present in our set of search terms.
        return searchTerms.Contains(element.Name);
    }

    private Color GetSecurityColor(string security) => security.ToLower() switch
    {
        "recommended" => Color.Success,
        "secure" => Color.Info,
        "weak" => Color.Warning,
        "insecure" => Color.Error,
        _ => Color.Default
    };
}