// Services/ComponentTaskRunner.cs
using System.Threading;

public class ComponentTaskRunner : IDisposable
{
    private CancellationTokenSource? _cts;
    // The asynchronous lock. Initial count = 1, Max count = 1.
    private readonly SemaphoreSlim _lock = new SemaphoreSlim(1, 1);

    public void Start(TimeSpan interval, Action onStateHasChanged, params Func<Task>[] workFunctions)
    {
        if (workFunctions == null || workFunctions.Length == 0) return;

        _cts = new CancellationTokenSource();
        _ = DoContinuousWorkAsync(interval, onStateHasChanged, workFunctions, _cts.Token);
    }

    private async Task DoContinuousWorkAsync(TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            // First, wait for the specified interval.
            // This prevents an immediate run on startup before the first delay.
            try
            {
                await Task.Delay(interval, token);
            }
            catch (OperationCanceledException) { break; }

            // Now, try to acquire the lock without waiting.
            if (!await _lock.WaitAsync(0, token))
            {
                // If we couldn't get the lock, it means the previous task is still running.
                // So, we skip this cycle and go back to waiting for the next interval.
                Console.WriteLine($"[{DateTime.Now:T}] Skipping task run because the previous one is still active.");
                continue;
            }

            try
            {
                // --- We have acquired the lock ---
                // We are now certain that no other instance of this work is running.

                await Task.Run(async () =>
                {
                    foreach (var work in workFunctions)
                    {
                        if (token.IsCancellationRequested) break;
                        await work();
                    }
                }, token);

                if (!token.IsCancellationRequested)
                {
                    onStateHasChanged?.Invoke();
                }
            }
            finally
            {
                // CRITICAL: Always release the lock in a finally block.
                // This ensures that even if the work throws an exception,
                // the lock is released, preventing a permanent deadlock.
                _lock.Release();
            }
        }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _lock?.Dispose();
    }
}```