That exception means your call used a **relative URL while `HttpClient.BaseAddress` was null**, or you passed a string that isn’t a valid URI. Fix it by (1) ensuring each client has a BaseAddress, and (2) only passing **relative, URL-safe** paths to that client.

# 1) Set BaseAddress per API (Blazor Server, typed clients)

**Program.cs**

```csharp
var cfg = builder.Configuration;

builder.Services.AddHttpClient<Api1Service>(c =>
{
    c.BaseAddress = RequireHttpsBase(cfg["Apis:Api1:BaseUrl"]); // e.g. "https://api1.example.com/"
    c.DefaultRequestHeaders.Accept.ParseAdd("application/json");
});

builder.Services.AddHttpClient<Api2Service>(c =>
{
    c.BaseAddress = RequireHttpsBase(cfg["Apis:Api2:BaseUrl"]); // e.g. "https://api2.example.com/"
    c.DefaultRequestHeaders.Accept.ParseAdd("application/json");
});

// Fail fast if config is missing/invalid
static Uri RequireHttpsBase(string? url)
{
    if (!Uri.TryCreate(url?.Trim(), UriKind.Absolute, out var u) ||
        (u.Scheme != Uri.UriSchemeHttps && u.Scheme != Uri.UriSchemeHttp))
        throw new InvalidOperationException($"Invalid API BaseUrl: '{url}' (must be absolute, include http/https).");
    return u;
}
```

# 2) Pass **relative** and **encoded** paths from services

**api1service.cs**

```csharp
using Microsoft.AspNetCore.WebUtilities; // QueryHelpers
using System.Net.Http.Json;

public sealed class Api1Service
{
    private readonly HttpClient _http;
    public Api1Service(HttpClient http)
    {
        _http = http;
        if (_http.BaseAddress is null)
            throw new InvalidOperationException("Api1Service HttpClient.BaseAddress is null. Check Program.cs/config.");
    }

    // GET https://api1.../v1/items
    public Task<List<ItemDto>?> GetItemsAsync(CancellationToken ct = default) =>
        _http.GetFromJsonAsync<List<ItemDto>>("v1/items", ct);

    // GET https://api1.../v1/items/{id}
    public Task<ItemDto?> GetItemAsync(string id, CancellationToken ct = default)
    {
        var safeId = Uri.EscapeDataString(id ?? string.Empty);
        return _http.GetFromJsonAsync<ItemDto>($"v1/items/{safeId}", ct);
    }

    // GET https://api1.../v1/search?q=your+query
    public Task<SearchResult?> SearchAsync(string q, CancellationToken ct = default)
    {
        var url = QueryHelpers.AddQueryString("v1/search", new() { ["q"] = q ?? string.Empty });
        return _http.GetFromJsonAsync<SearchResult>(url, ct);
    }
}
```

# 3) Quick “why it still breaks” checklist

* **Config key missing/empty** → BaseAddress stays null. Verify with:

  ```csharp
  Console.WriteLine($"Api1 Base: {builder.Configuration["Apis:Api1:BaseUrl"]}");
  ```
* **You passed an absolute URL string** *without* BaseAddress → fine; but if the string is malformed (no scheme, spaces, backslashes), you’ll get this error. Prefer `new Uri(string, UriKind.Absolute)` validation or just set BaseAddress and pass relative paths.
* **Illegal characters** in path/query → always use `Uri.EscapeDataString` for segments and `QueryHelpers.AddQueryString` for queries.
* **Empty or whitespace path** → calling `GetAsync("")` is valid (hits BaseAddress), but `null` or strings with control chars will throw.

# 4) Log the final URL during debugging

```csharp
var rel = QueryHelpers.AddQueryString("v1/search", new() { ["q"] = q });
Console.WriteLine($"[Api1] GET {_http.BaseAddress}{rel}");
using var resp = await _http.GetAsync(rel, ct);
```

Do the three things above—**valid BaseAddress**, **relative+encoded paths**, **guard in the service constructor**—and that “invalid request URI” error will go away. If you share one failing call (the exact string you pass to `HttpClient`) and your `Apis:Api1:BaseUrl` value, I’ll pinpoint the exact fix.
