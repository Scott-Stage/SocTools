// Services/ComponentTaskRunner.cs
using System.Collections.Concurrent;
using System.Threading;

public class ComponentTaskRunner : IDisposable
{
    // The KEY is the unique task name. The VALUE is its personal "off switch".
    private readonly ConcurrentDictionary<string, CancellationTokenSource> _runningTasks = new();

    // Start now takes a unique name for the task.
    public void Start(
        string taskName,
        TimeSpan interval,
        Action onStateHasChanged,
        params Func<Task>[] workFunctions)
    {
        // Try to add a new task. If the name already exists, do nothing.
        // This makes the Start operation idempotent and safe to call multiple times.
        if (!_runningTasks.TryAdd(taskName, new CancellationTokenSource()))
        {
            // A task with this name is already running.
            return;
        }

        var cts = _runningTasks[taskName];

        // Start the independent loop for this specific task.
        _ = DoContinuousWorkAsync(taskName, interval, onStateHasChanged, workFunctions, cts.Token);
    }

    // Stop now takes the name of the task to stop.
    public void Stop(string taskName)
    {
        // Try to remove the task from the dictionary. If successful, we get its CTS.
        if (_runningTasks.TryRemove(taskName, out var cts))
        {
            // Signal cancellation and dispose of the CTS for that specific task.
            cts.Cancel();
            cts.Dispose();
        }
    }
    
    // A helper to check the status of a specific task.
    public bool IsRunning(string taskName)
    {
        return _runningTasks.ContainsKey(taskName);
    }

    // A convenience method to stop all managed tasks.
    public void StopAll()
    {
        foreach (var taskName in _runningTasks.Keys)
        {
            Stop(taskName);
        }
    }

    private async Task DoContinuousWorkAsync(string taskName, TimeSpan interval, Action onStateHasChanged, Func<Task>[] workFunctions, CancellationToken token)
    {
        // This loop is now entirely independent for each task.
        // NOTE: For this manager pattern, we remove the SemaphoreSlim to allow
        // independent tasks to run truly concurrently. Each task is its own "job".
        while (!token.IsCancellationRequested)
        {
            try { await Task.Delay(interval, token); }
            catch (OperationCanceledException) { break; }

            try
            {
                await Task.Run(async () =>
                {
                    foreach (var work in workFunctions)
                    {
                        if (token.IsCancellationRequested) break;
                        await work();
                    }
                }, token);

                if (!token.IsCancellationRequested)
                {
                    onStateHasChanged?.Invoke();
                }
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in background task '{taskName}': {ex.Message}");
            }
        }
    }

    // Dispose is the final safety net that stops everything.
    public void Dispose()
    {
        StopAll();
    }
}