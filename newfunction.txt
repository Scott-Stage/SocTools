To group the results by device, you need to transform the "Flat List" of vulnerabilities into a "Hierarchical List" (Device -> Vulnerabilities).
Since the standard TenableVulnerability object contains host information (IP, DNS, OS) on every single row, we can group by IP Address, extract the host details from the first record in that group, and then store the list of vulnerabilities under that host.
1. The New Data Model
First, create a class to represent the "Device" or "Asset" container.
code
C#
public class TenableDeviceAsset
{
    public string? IpAddress { get; set; }
    public string? DnsName { get; set; }
    public string? Os { get; set; }
    
    // Summary Counts (Optional but useful)
    public int CriticalCount { get; set; }
    public int HighCount { get; set; }
    
    // The list of vulns specific to this device
    public List<TenableVulnerability> Vulnerabilities { get; set; } = new();
}
2. The Modified Method
Here is the updated method. The fetching logic is identical, but the return type and the final processing step (Step 4) are changed to handle the grouping.
code
C#
// Change Return Type to List<TenableDeviceAsset>
public async Task<List<TenableDeviceAsset>> GetVulnsGroupedByDevice(string specificPluginIds)
{
    // ---------------------------------------------------------
    // Steps 1-3: Fetch Data (Exactly the same as before)
    // ---------------------------------------------------------
    
    // Request 1: Highs and Criticals
    var highCritRequest = new TenableAnalysisRequest
    {
        Type = "vuln",
        Query = new TenableQuery
        {
            Tool = "listvuln",
            SourceType = "cumulative",
            Filters = new List<TenableFilter>
            {
                new TenableFilter { FilterName = "severity", Operator = "=", Value = "3,4" },
                new TenableFilter { FilterName = "pluginType", Operator = "=", Value = "active" }
            }
        }
    };

    // Request 2: Specific Info Plugins (19506, etc.)
    var specificInfoRequest = new TenableAnalysisRequest
    {
        Type = "vuln",
        Query = new TenableQuery
        {
            Tool = "listvuln",
            SourceType = "cumulative",
            Filters = new List<TenableFilter>
            {
                new TenableFilter { FilterName = "pluginID", Operator = "=", Value = specificPluginIds }
            }
        }
    };

    var taskHigh = FetchVulns(highCritRequest);
    var taskInfo = FetchVulns(specificInfoRequest);

    await Task.WhenAll(taskHigh, taskInfo);

    // ---------------------------------------------------------
    // Step 4: Merge and Group by IP
    // ---------------------------------------------------------

    // 1. Flatten into one big list and remove exact duplicates
    var rawList = taskHigh.Result
        .Concat(taskInfo.Result)
        .GroupBy(v => v.PluginId + v.IpAddress + v.Port + v.Protocol)
        .Select(g => g.First())
        .ToList();

    // 2. Group by IP Address to create Device objects
    var groupedDevices = rawList
        .GroupBy(v => v.IpAddress) // Key is the IP
        .Select(group => new TenableDeviceAsset
        {
            IpAddress = group.Key,
            
            // Host Metadata is repeated on every vuln row, so just grab the first one that isn't null
            DnsName = group.FirstOrDefault(v => !string.IsNullOrEmpty(v.DnsName))?.DnsName,
            Os = group.FirstOrDefault(v => !string.IsNullOrEmpty(v.Os))?.Os,
            
            // Calculate counts based on the 'Severity' object (assuming Id "4" is Crit, "3" is High)
            CriticalCount = group.Count(v => v.Severity?.Id == "4"),
            HighCount = group.Count(v => v.Severity?.Id == "3"),

            // The list of actual vulnerabilities for this IP
            Vulnerabilities = group
                .OrderByDescending(v => v.Severity?.Id) // Sort Crits to top
                .ThenBy(v => v.PluginName)
                .ToList()
        })
        .OrderBy(d => d.IpAddress) // Sort devices by IP
        .ToList();

    return groupedDevices;
}

// Helper method remains the same
private async Task<List<TenableVulnerability>> FetchVulns(TenableAnalysisRequest req)
{
    string json = JsonSerializer.Serialize(req);
    using var content = new StringContent(json, Encoding.UTF8, "application/json");
    
    var response = await _httpClient.PostAsync($"{base_url}/analysis", content);
    // Note: Always safer to check IsSuccessStatusCode here
    if (!response.IsSuccessStatusCode) return new List<TenableVulnerability>();

    var respString = await response.Content.ReadAsStringAsync();
    var result = JsonSerializer.Deserialize<TenableScResponse<TenableAnalysisResult>>(respString);
    return result?.Response?.Results ?? new List<TenableVulnerability>();
}